# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.internal_server_error import InternalServerError
from ...types.ml_backend import MlBackend
from .types.api_ml_create_response import ApiMlCreateResponse
from .types.ml_interactive_annotating_request_context import MlInteractiveAnnotatingRequestContext

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class MachineLearningClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def api_ml_list(self, *, project: typing.Optional[int] = None) -> typing.List[MlBackend]:
        """
        List all configured ML backends for a specific project by ID.
        Use the following cURL command:

        ```bash
        curl https://localhost:8080/api/ml?project={project_id} -H 'Authorization: Token abc123'
        ```

        Parameters:
            - project: typing.Optional[int]. Project ID
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.machine_learning.api_ml_list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/ml/"),
            params=remove_none_from_dict({"project": project}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[MlBackend], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_ml_create(
        self, *, project: typing.Optional[int] = OMIT, url: typing.Optional[str] = OMIT
    ) -> ApiMlCreateResponse:
        """
        Add an ML backend to a project using the Label Studio UI or by sending a POST request using the following cURL
        command:
        
        ```bash
        curl -X POST -H 'Content-type: application/json' https://localhost:8080/api/ml -H 'Authorization: Token abc123'\
        --data '{"url": "http://localhost:9090", "project": {project_id}}'
        ```
        
        Parameters:
            - project: typing.Optional[int]. Project ID
            
            - url: typing.Optional[str]. ML backend URL
        ---
        from label-studio.client import LabelStudioApi
        
        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.machine_learning.api_ml_create()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if project is not OMIT:
            _request["project"] = project
        if url is not OMIT:
            _request["url"] = url
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/ml/"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiMlCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_ml_read(self, id: int) -> MlBackend:
        """
        Get details about a specific ML backend connection by ID. For example, make a GET request using the
        following cURL command:

        ```bash
        curl https://localhost:8080/api/ml/{ml_backend_ID} -H 'Authorization: Token abc123'
        ```

        Parameters:
            - id: int. A unique integer value identifying this ml backend.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.machine_learning.api_ml_read(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(MlBackend, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_ml_delete(self, id: int) -> None:
        """
        Remove an existing ML backend connection by ID. For example, use the
        following cURL command:

        ```bash
        curl -X DELETE https://localhost:8080/api/ml/{ml_backend_ID} -H 'Authorization: Token abc123'
        ```

        Parameters:
            - id: int. A unique integer value identifying this ml backend.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.machine_learning.api_ml_delete(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_ml_partial_update(self, id: int, *, request: MlBackend) -> MlBackend:
        """
        Update ML backend parameters using the Label Studio UI or by sending a PATCH request using the following cURL command:
        
        ```bash
        curl -X PATCH -H 'Content-type: application/json' https://localhost:8080/api/ml/{ml_backend_ID} -H 'Authorization: Token abc123'\
        --data '{"url": "http://localhost:9091"}'
        ```
        
        Parameters:
            - id: int. A unique integer value identifying this ml backend.
            
            - request: MlBackend.
        ---
        from label-studio import MlBackend
        from label-studio.client import LabelStudioApi
        
        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.machine_learning.api_ml_partial_update(id=1, request=MlBackend(url="url", project=1, ), )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(MlBackend, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_ml_interactive_annotating_create(
        self, id: int, *, task: int, context: typing.Optional[MlInteractiveAnnotatingRequestContext] = OMIT
    ) -> None:
        """
        Send a request to the machine learning backend set up to be used for interactive preannotations to retrieve a
        predicted region based on annotator input.
        See [set up machine learning](https://labelstud.io/guide/ml.html#Get-interactive-preannotations) for more.

        Parameters:
            - id: int. A unique integer value identifying this ML backend.

            - task: int. ID of task to annotate

            - context: typing.Optional[MlInteractiveAnnotatingRequestContext]. Context for ML model
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.machine_learning.api_ml_interactive_annotating_create(id=1, task=1, )
        """
        _request: typing.Dict[str, typing.Any] = {"task": task}
        if context is not OMIT:
            _request["context"] = context
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}/interactive-annotating"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_ml_predict_test_create(self, id: int) -> None:
        """
        After you add an ML backend, call this API with the ML backend ID to run a test prediction on specific task data

        Parameters:
            - id: int. A unique integer value identifying this ML backend.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.machine_learning.api_ml_predict_test_create(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}/predict/test"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_ml_train_create(self, id: int, *, use_ground_truth: typing.Optional[bool] = OMIT) -> None:
        """
        After you add an ML backend, call this API with the ML backend ID to start training with
        already-labeled tasks.

        Get the ML backend ID by [listing the ML backends for a project](https://labelstud.io/api/#operation/api_ml_list).

        Parameters:
            - id: int. A unique integer value identifying this ML backend.

            - use_ground_truth: typing.Optional[bool]. Whether to include ground truth annotations in training
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.machine_learning.api_ml_train_create(id=1, )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if use_ground_truth is not OMIT:
            _request["use_ground_truth"] = use_ground_truth
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}/train"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_ml_versions_read(self, id: str) -> None:
        """
        Get available versions of the model.

        Parameters:
            - id: str.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.machine_learning.api_ml_versions_read(id="id", )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}/versions"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncMachineLearningClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def api_ml_list(self, *, project: typing.Optional[int] = None) -> typing.List[MlBackend]:
        """
        List all configured ML backends for a specific project by ID.
        Use the following cURL command:

        ```bash
        curl https://localhost:8080/api/ml?project={project_id} -H 'Authorization: Token abc123'
        ```

        Parameters:
            - project: typing.Optional[int]. Project ID
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.machine_learning.api_ml_list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/ml/"),
            params=remove_none_from_dict({"project": project}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[MlBackend], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_ml_create(
        self, *, project: typing.Optional[int] = OMIT, url: typing.Optional[str] = OMIT
    ) -> ApiMlCreateResponse:
        """
        Add an ML backend to a project using the Label Studio UI or by sending a POST request using the following cURL
        command:
        
        ```bash
        curl -X POST -H 'Content-type: application/json' https://localhost:8080/api/ml -H 'Authorization: Token abc123'\
        --data '{"url": "http://localhost:9090", "project": {project_id}}'
        ```
        
        Parameters:
            - project: typing.Optional[int]. Project ID
            
            - url: typing.Optional[str]. ML backend URL
        ---
        from label-studio.client import AsyncLabelStudioApi
        
        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.machine_learning.api_ml_create()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if project is not OMIT:
            _request["project"] = project
        if url is not OMIT:
            _request["url"] = url
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/ml/"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiMlCreateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_ml_read(self, id: int) -> MlBackend:
        """
        Get details about a specific ML backend connection by ID. For example, make a GET request using the
        following cURL command:

        ```bash
        curl https://localhost:8080/api/ml/{ml_backend_ID} -H 'Authorization: Token abc123'
        ```

        Parameters:
            - id: int. A unique integer value identifying this ml backend.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.machine_learning.api_ml_read(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(MlBackend, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_ml_delete(self, id: int) -> None:
        """
        Remove an existing ML backend connection by ID. For example, use the
        following cURL command:

        ```bash
        curl -X DELETE https://localhost:8080/api/ml/{ml_backend_ID} -H 'Authorization: Token abc123'
        ```

        Parameters:
            - id: int. A unique integer value identifying this ml backend.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.machine_learning.api_ml_delete(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_ml_partial_update(self, id: int, *, request: MlBackend) -> MlBackend:
        """
        Update ML backend parameters using the Label Studio UI or by sending a PATCH request using the following cURL command:
        
        ```bash
        curl -X PATCH -H 'Content-type: application/json' https://localhost:8080/api/ml/{ml_backend_ID} -H 'Authorization: Token abc123'\
        --data '{"url": "http://localhost:9091"}'
        ```
        
        Parameters:
            - id: int. A unique integer value identifying this ml backend.
            
            - request: MlBackend.
        ---
        from label-studio import MlBackend
        from label-studio.client import AsyncLabelStudioApi
        
        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.machine_learning.api_ml_partial_update(id=1, request=MlBackend(url="url", project=1, ), )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(MlBackend, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_ml_interactive_annotating_create(
        self, id: int, *, task: int, context: typing.Optional[MlInteractiveAnnotatingRequestContext] = OMIT
    ) -> None:
        """
        Send a request to the machine learning backend set up to be used for interactive preannotations to retrieve a
        predicted region based on annotator input.
        See [set up machine learning](https://labelstud.io/guide/ml.html#Get-interactive-preannotations) for more.

        Parameters:
            - id: int. A unique integer value identifying this ML backend.

            - task: int. ID of task to annotate

            - context: typing.Optional[MlInteractiveAnnotatingRequestContext]. Context for ML model
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.machine_learning.api_ml_interactive_annotating_create(id=1, task=1, )
        """
        _request: typing.Dict[str, typing.Any] = {"task": task}
        if context is not OMIT:
            _request["context"] = context
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}/interactive-annotating"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_ml_predict_test_create(self, id: int) -> None:
        """
        After you add an ML backend, call this API with the ML backend ID to run a test prediction on specific task data

        Parameters:
            - id: int. A unique integer value identifying this ML backend.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.machine_learning.api_ml_predict_test_create(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}/predict/test"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_ml_train_create(self, id: int, *, use_ground_truth: typing.Optional[bool] = OMIT) -> None:
        """
        After you add an ML backend, call this API with the ML backend ID to start training with
        already-labeled tasks.

        Get the ML backend ID by [listing the ML backends for a project](https://labelstud.io/api/#operation/api_ml_list).

        Parameters:
            - id: int. A unique integer value identifying this ML backend.

            - use_ground_truth: typing.Optional[bool]. Whether to include ground truth annotations in training
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.machine_learning.api_ml_train_create(id=1, )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if use_ground_truth is not OMIT:
            _request["use_ground_truth"] = use_ground_truth
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}/train"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_ml_versions_read(self, id: str) -> None:
        """
        Get available versions of the model.

        Parameters:
            - id: str.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.machine_learning.api_ml_versions_read(id="id", )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/ml/{id}/versions"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
