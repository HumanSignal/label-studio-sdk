# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...types.annotation import Annotation
from ...types.file_upload import FileUpload
from ...types.prediction import Prediction
from .types.api_projects_import_create_response import ApiProjectsImportCreateResponse
from .types.import_api_data import ImportApiData
from .types.import_api_meta import ImportApiMeta

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProjectImportClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def api_import_file_upload_read(self, id: int) -> FileUpload:
        """
        Retrieve details about a specific uploaded file.

        Parameters:
            - id: int. A unique integer value identifying this file upload.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.project_import.api_import_file_upload_read(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileUpload, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_import_file_upload_delete(self, id: int) -> None:
        """
        Delete a specific uploaded file.

        Parameters:
            - id: int. A unique integer value identifying this file upload.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.project_import.api_import_file_upload_delete(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_import_file_upload_partial_update(self, id: int, *, request: FileUpload) -> FileUpload:
        """
        Update a specific uploaded file.

        Parameters:
            - id: int. A unique integer value identifying this file upload.

            - request: FileUpload.
        ---
        from label-studio import FileUpload
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.project_import.api_import_file_upload_partial_update(id=1, request=FileUpload(), )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileUpload, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_file_uploads_list(
        self,
        id: int,
        *,
        all_: typing.Optional[bool] = None,
        ids: typing.Optional[typing.Union[int, typing.List[int]]] = None,
    ) -> typing.List[FileUpload]:
        """
        Retrieve the list of uploaded files used to create labeling tasks for a specific project.

        Parameters:
            - id: int. A unique integer value identifying this file upload.

            - all_: typing.Optional[bool]. Set to "true" if you want to retrieve all file uploads

            - ids: typing.Optional[typing.Union[int, typing.List[int]]]. Specify the list of file upload IDs to retrieve, e.g. ids=[1,2,3]
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.project_import.api_projects_file_uploads_list(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/projects/{id}/file-uploads"),
            params=remove_none_from_dict({"all": all_, "ids": ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[FileUpload], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_file_uploads_delete(self, id: int) -> None:
        """
        Delete uploaded files for a specific project.

        Parameters:
            - id: int. A unique integer value identifying this file upload.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.project_import.api_projects_file_uploads_delete(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/projects/{id}/file-uploads"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_import_create(
        self,
        id: int,
        *,
        import_api_id: typing.Optional[int] = OMIT,
        annotations: typing.Optional[typing.List[Annotation]] = OMIT,
        predictions: typing.Optional[typing.List[Prediction]] = OMIT,
        data: ImportApiData,
        meta: typing.Optional[ImportApiMeta] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.List[int]] = OMIT,
    ) -> ApiProjectsImportCreateResponse:
        """
        Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
        One POST request is limited at 250K tasks and 200 MB.
        
        **Note:** Imported data is verified against a project _label_config_ and must
        include all variables that were used in the _label_config_. For example,
        if the label configuration has a _$text_ variable, then each item in a data object
        must include a "text" field.
        <br>
        
        ## POST requests
        
        <hr style="opacity:0.3">
        
        There are three possible ways to import tasks with this endpoint:
        
        ### 1\. **POST with data**
        
        Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
        Update this example to specify your authorization token and Label Studio instance host, then run the following from
        the command line.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
        ```
        
        ### 2\. **POST with files**
        
        Send tasks as files. You can attach multiple files with different names.
        
        - **JSON**: text files in JavaScript object notation format
        - **CSV**: text files with tables in Comma Separated Values format
        - **TSV**: text files with tables in Tab Separated Value format
        - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
        Update this example to specify your authorization token, Label Studio instance host, and file name and path,
        then run the following from the command line:
        
        ```bash
        curl -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' -F ‘file=@path/to/my_file.csv’
        ```
        
        ### 3\. **POST with URL**
        
        You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' \
        --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
        ```
        
        <br>
        
        Parameters:
            - id: int. A unique integer value identifying this project.
            
            - import_api_id: typing.Optional[int].
            
            - annotations: typing.Optional[typing.List[Annotation]].
            
            - predictions: typing.Optional[typing.List[Prediction]].
            
            - data: ImportApiData. User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.
            
            - meta: typing.Optional[ImportApiMeta]. Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.
            
            - created_at: typing.Optional[dt.datetime]. Time a task was created
            
            - updated_at: typing.Optional[dt.datetime]. Last time a task was updated
            
            - overlap: typing.Optional[int]. Number of distinct annotators that processed the current task
            
            - inner_id: typing.Optional[int]. Internal task ID in the project, starts with 1
            
            - total_annotations: typing.Optional[int]. Number of total annotations for the current task except cancelled annotations
            
            - cancelled_annotations: typing.Optional[int]. Number of total cancelled annotations for the current task
            
            - total_predictions: typing.Optional[int]. Number of total predictions for the current task
            
            - comment_count: typing.Optional[int]. Number of comments in the task including all annotations
            
            - unresolved_comment_count: typing.Optional[int]. Number of unresolved comments in the task including all annotations
            
            - last_comment_updated_at: typing.Optional[dt.datetime]. When the last comment was updated
            
            - updated_by: typing.Optional[int]. Last annotator or reviewer who updated this task
            
            - file_upload: typing.Optional[int]. Uploaded file used as data source for this task
            
            - comment_authors: typing.Optional[typing.List[int]]. Users who wrote comments
        ---
        from label-studio import ImportApiData
        from label-studio.client import LabelStudioApi
        
        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.project_import.api_projects_import_create(id=1, data=ImportApiData(), )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if import_api_id is not OMIT:
            _request["id"] = import_api_id
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if predictions is not OMIT:
            _request["predictions"] = predictions
        if meta is not OMIT:
            _request["meta"] = meta
        if created_at is not OMIT:
            _request["created_at"] = created_at
        if updated_at is not OMIT:
            _request["updated_at"] = updated_at
        if overlap is not OMIT:
            _request["overlap"] = overlap
        if inner_id is not OMIT:
            _request["inner_id"] = inner_id
        if total_annotations is not OMIT:
            _request["total_annotations"] = total_annotations
        if cancelled_annotations is not OMIT:
            _request["cancelled_annotations"] = cancelled_annotations
        if total_predictions is not OMIT:
            _request["total_predictions"] = total_predictions
        if comment_count is not OMIT:
            _request["comment_count"] = comment_count
        if unresolved_comment_count is not OMIT:
            _request["unresolved_comment_count"] = unresolved_comment_count
        if last_comment_updated_at is not OMIT:
            _request["last_comment_updated_at"] = last_comment_updated_at
        if updated_by is not OMIT:
            _request["updated_by"] = updated_by
        if file_upload is not OMIT:
            _request["file_upload"] = file_upload
        if comment_authors is not OMIT:
            _request["comment_authors"] = comment_authors
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/projects/{id}/import"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiProjectsImportCreateResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProjectImportClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def api_import_file_upload_read(self, id: int) -> FileUpload:
        """
        Retrieve details about a specific uploaded file.

        Parameters:
            - id: int. A unique integer value identifying this file upload.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.project_import.api_import_file_upload_read(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileUpload, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_import_file_upload_delete(self, id: int) -> None:
        """
        Delete a specific uploaded file.

        Parameters:
            - id: int. A unique integer value identifying this file upload.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.project_import.api_import_file_upload_delete(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_import_file_upload_partial_update(self, id: int, *, request: FileUpload) -> FileUpload:
        """
        Update a specific uploaded file.

        Parameters:
            - id: int. A unique integer value identifying this file upload.

            - request: FileUpload.
        ---
        from label-studio import FileUpload
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.project_import.api_import_file_upload_partial_update(id=1, request=FileUpload(), )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{id}"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileUpload, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_file_uploads_list(
        self,
        id: int,
        *,
        all_: typing.Optional[bool] = None,
        ids: typing.Optional[typing.Union[int, typing.List[int]]] = None,
    ) -> typing.List[FileUpload]:
        """
        Retrieve the list of uploaded files used to create labeling tasks for a specific project.

        Parameters:
            - id: int. A unique integer value identifying this file upload.

            - all_: typing.Optional[bool]. Set to "true" if you want to retrieve all file uploads

            - ids: typing.Optional[typing.Union[int, typing.List[int]]]. Specify the list of file upload IDs to retrieve, e.g. ids=[1,2,3]
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.project_import.api_projects_file_uploads_list(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/projects/{id}/file-uploads"),
            params=remove_none_from_dict({"all": all_, "ids": ids}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[FileUpload], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_file_uploads_delete(self, id: int) -> None:
        """
        Delete uploaded files for a specific project.

        Parameters:
            - id: int. A unique integer value identifying this file upload.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.project_import.api_projects_file_uploads_delete(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/projects/{id}/file-uploads"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_import_create(
        self,
        id: int,
        *,
        import_api_id: typing.Optional[int] = OMIT,
        annotations: typing.Optional[typing.List[Annotation]] = OMIT,
        predictions: typing.Optional[typing.List[Prediction]] = OMIT,
        data: ImportApiData,
        meta: typing.Optional[ImportApiMeta] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.List[int]] = OMIT,
    ) -> ApiProjectsImportCreateResponse:
        """
        Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
        One POST request is limited at 250K tasks and 200 MB.
        
        **Note:** Imported data is verified against a project _label_config_ and must
        include all variables that were used in the _label_config_. For example,
        if the label configuration has a _$text_ variable, then each item in a data object
        must include a "text" field.
        <br>
        
        ## POST requests
        
        <hr style="opacity:0.3">
        
        There are three possible ways to import tasks with this endpoint:
        
        ### 1\. **POST with data**
        
        Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
        Update this example to specify your authorization token and Label Studio instance host, then run the following from
        the command line.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
        ```
        
        ### 2\. **POST with files**
        
        Send tasks as files. You can attach multiple files with different names.
        
        - **JSON**: text files in JavaScript object notation format
        - **CSV**: text files with tables in Comma Separated Values format
        - **TSV**: text files with tables in Tab Separated Value format
        - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
        Update this example to specify your authorization token, Label Studio instance host, and file name and path,
        then run the following from the command line:
        
        ```bash
        curl -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' -F ‘file=@path/to/my_file.csv’
        ```
        
        ### 3\. **POST with URL**
        
        You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' \
        --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
        ```
        
        <br>
        
        Parameters:
            - id: int. A unique integer value identifying this project.
            
            - import_api_id: typing.Optional[int].
            
            - annotations: typing.Optional[typing.List[Annotation]].
            
            - predictions: typing.Optional[typing.List[Prediction]].
            
            - data: ImportApiData. User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.
            
            - meta: typing.Optional[ImportApiMeta]. Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.
            
            - created_at: typing.Optional[dt.datetime]. Time a task was created
            
            - updated_at: typing.Optional[dt.datetime]. Last time a task was updated
            
            - overlap: typing.Optional[int]. Number of distinct annotators that processed the current task
            
            - inner_id: typing.Optional[int]. Internal task ID in the project, starts with 1
            
            - total_annotations: typing.Optional[int]. Number of total annotations for the current task except cancelled annotations
            
            - cancelled_annotations: typing.Optional[int]. Number of total cancelled annotations for the current task
            
            - total_predictions: typing.Optional[int]. Number of total predictions for the current task
            
            - comment_count: typing.Optional[int]. Number of comments in the task including all annotations
            
            - unresolved_comment_count: typing.Optional[int]. Number of unresolved comments in the task including all annotations
            
            - last_comment_updated_at: typing.Optional[dt.datetime]. When the last comment was updated
            
            - updated_by: typing.Optional[int]. Last annotator or reviewer who updated this task
            
            - file_upload: typing.Optional[int]. Uploaded file used as data source for this task
            
            - comment_authors: typing.Optional[typing.List[int]]. Users who wrote comments
        ---
        from label-studio import ImportApiData
        from label-studio.client import AsyncLabelStudioApi
        
        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.project_import.api_projects_import_create(id=1, data=ImportApiData(), )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if import_api_id is not OMIT:
            _request["id"] = import_api_id
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if predictions is not OMIT:
            _request["predictions"] = predictions
        if meta is not OMIT:
            _request["meta"] = meta
        if created_at is not OMIT:
            _request["created_at"] = created_at
        if updated_at is not OMIT:
            _request["updated_at"] = updated_at
        if overlap is not OMIT:
            _request["overlap"] = overlap
        if inner_id is not OMIT:
            _request["inner_id"] = inner_id
        if total_annotations is not OMIT:
            _request["total_annotations"] = total_annotations
        if cancelled_annotations is not OMIT:
            _request["cancelled_annotations"] = cancelled_annotations
        if total_predictions is not OMIT:
            _request["total_predictions"] = total_predictions
        if comment_count is not OMIT:
            _request["comment_count"] = comment_count
        if unresolved_comment_count is not OMIT:
            _request["unresolved_comment_count"] = unresolved_comment_count
        if last_comment_updated_at is not OMIT:
            _request["last_comment_updated_at"] = last_comment_updated_at
        if updated_by is not OMIT:
            _request["updated_by"] = updated_by
        if file_upload is not OMIT:
            _request["file_upload"] = file_upload
        if comment_authors is not OMIT:
            _request["comment_authors"] = comment_authors
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/projects/{id}/import"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiProjectsImportCreateResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
