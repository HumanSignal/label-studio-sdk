# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...types.label import Label
from ...types.label_create import LabelCreate
from ...types.label_link import LabelLink
from .types.api_label_links_list_response import ApiLabelLinksListResponse
from .types.api_labels_list_response import ApiLabelsListResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class LabelsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def api_label_links_list(
        self,
        *,
        project: typing.Optional[str] = None,
        label_created_at: typing.Optional[str] = None,
        label_created_at_gte: typing.Optional[str] = None,
        label_created_at_lte: typing.Optional[str] = None,
        label_created_by: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
    ) -> ApiLabelLinksListResponse:
        """
        List label links for a specific label and project.

        Parameters:
            - project: typing.Optional[str]. project

            - label_created_at: typing.Optional[str]. label\_\_created_at

            - label_created_at_gte: typing.Optional[str]. label**created_at**gte

            - label_created_at_lte: typing.Optional[str]. label**created_at**lte

            - label_created_by: typing.Optional[str]. label\_\_created_by

            - page: typing.Optional[int]. A page number within the paginated result set.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_label_links_list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/label_links/"),
            params=remove_none_from_dict(
                {
                    "project": project,
                    "label__created_at": label_created_at,
                    "label__created_at__gte": label_created_at_gte,
                    "label__created_at__lte": label_created_at_lte,
                    "label__created_by": label_created_by,
                    "page": page,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiLabelLinksListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_label_links_create(self, *, request: LabelLink) -> LabelLink:
        """
        Create label links to link new custom labels to your project labeling configuration.

        Parameters:
            - request: LabelLink.
        ---
        from label-studio import LabelLink
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_label_links_create(request=LabelLink(from_name="from_name", project=1, label=1, ), )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/label_links/"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LabelLink, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_label_links_read(self, id: str) -> LabelLink:
        """
        Get label links for a specific project configuration.

        Parameters:
            - id: str.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_label_links_read(id="id", )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/label_links/{id}/"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LabelLink, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_label_links_delete(self, id: str) -> None:
        """
        Remove a label link that links custom labels to your project labeling configuration. If you remove a label link,
        the label stops being available for the project it was linked to. You can add a new label link at any time.

        Parameters:
            - id: str.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_label_links_delete(id="id", )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/label_links/{id}/"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_label_links_partial_update(self, id: str, *, request: LabelLink) -> LabelLink:
        """
        Update a label link that links custom labels to a project labeling configuration, for example if the fromName,
        toName, or name parameters for a tag in the labeling configuration change.

        Parameters:
            - id: str.

            - request: LabelLink.
        ---
        from label-studio import LabelLink
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_label_links_partial_update(id="id", request=LabelLink(from_name="from_name", project=1, label=1, ), )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/label_links/{id}/"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LabelLink, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_labels_list(self, *, page: typing.Optional[int] = None) -> ApiLabelsListResponse:
        """
        List all custom labels added to your project separately from the labeling configuration.

        Parameters:
            - page: typing.Optional[int]. A page number within the paginated result set.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_labels_list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/labels/"),
            params=remove_none_from_dict({"page": page}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiLabelsListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_labels_create(self, *, request: typing.List[LabelCreate]) -> typing.List[LabelCreate]:
        """
        Add labels to your project without updating the labeling configuration.

        Parameters:
            - request: typing.List[LabelCreate].
        ---
        from label-studio import LabelCreate, LabelCreateValue
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_labels_create(request=[LabelCreate(project=1, from_name="from_name", value=LabelCreateValue(), title="title", )], )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/labels/"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[LabelCreate], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_labels_bulk_create(self) -> None:
        """
        If you want to update the labels in saved annotations, use this endpoint.

        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_labels_bulk_create()
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/labels/bulk"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_labels_read(self, id: str) -> Label:
        """
        Retrieve a specific custom label used for your project by its ID.

        Parameters:
            - id: str.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_labels_read(id="id", )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/labels/{id}/"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Label, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_labels_delete(self, id: str) -> None:
        """
        Remove labels from your project without updating the labeling configuration.

        Parameters:
            - id: str.
        ---
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_labels_delete(id="id", )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/labels/{id}/"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_labels_partial_update(self, id: str, *, request: Label) -> Label:
        """
        Update labels used for your project without updating the labeling configuration.

        Parameters:
            - id: str.

            - request: Label.
        ---
        from label-studio import Label, LabelValue
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.labels.api_labels_partial_update(id="id", request=Label(value=LabelValue(), title="title", created_by=1, organization=1, ), )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/labels/{id}/"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Label, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncLabelsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def api_label_links_list(
        self,
        *,
        project: typing.Optional[str] = None,
        label_created_at: typing.Optional[str] = None,
        label_created_at_gte: typing.Optional[str] = None,
        label_created_at_lte: typing.Optional[str] = None,
        label_created_by: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
    ) -> ApiLabelLinksListResponse:
        """
        List label links for a specific label and project.

        Parameters:
            - project: typing.Optional[str]. project

            - label_created_at: typing.Optional[str]. label\_\_created_at

            - label_created_at_gte: typing.Optional[str]. label**created_at**gte

            - label_created_at_lte: typing.Optional[str]. label**created_at**lte

            - label_created_by: typing.Optional[str]. label\_\_created_by

            - page: typing.Optional[int]. A page number within the paginated result set.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_label_links_list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/label_links/"),
            params=remove_none_from_dict(
                {
                    "project": project,
                    "label__created_at": label_created_at,
                    "label__created_at__gte": label_created_at_gte,
                    "label__created_at__lte": label_created_at_lte,
                    "label__created_by": label_created_by,
                    "page": page,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiLabelLinksListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_label_links_create(self, *, request: LabelLink) -> LabelLink:
        """
        Create label links to link new custom labels to your project labeling configuration.

        Parameters:
            - request: LabelLink.
        ---
        from label-studio import LabelLink
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_label_links_create(request=LabelLink(from_name="from_name", project=1, label=1, ), )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/label_links/"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LabelLink, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_label_links_read(self, id: str) -> LabelLink:
        """
        Get label links for a specific project configuration.

        Parameters:
            - id: str.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_label_links_read(id="id", )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/label_links/{id}/"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LabelLink, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_label_links_delete(self, id: str) -> None:
        """
        Remove a label link that links custom labels to your project labeling configuration. If you remove a label link,
        the label stops being available for the project it was linked to. You can add a new label link at any time.

        Parameters:
            - id: str.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_label_links_delete(id="id", )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/label_links/{id}/"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_label_links_partial_update(self, id: str, *, request: LabelLink) -> LabelLink:
        """
        Update a label link that links custom labels to a project labeling configuration, for example if the fromName,
        toName, or name parameters for a tag in the labeling configuration change.

        Parameters:
            - id: str.

            - request: LabelLink.
        ---
        from label-studio import LabelLink
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_label_links_partial_update(id="id", request=LabelLink(from_name="from_name", project=1, label=1, ), )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/label_links/{id}/"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(LabelLink, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_labels_list(self, *, page: typing.Optional[int] = None) -> ApiLabelsListResponse:
        """
        List all custom labels added to your project separately from the labeling configuration.

        Parameters:
            - page: typing.Optional[int]. A page number within the paginated result set.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_labels_list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/labels/"),
            params=remove_none_from_dict({"page": page}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiLabelsListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_labels_create(self, *, request: typing.List[LabelCreate]) -> typing.List[LabelCreate]:
        """
        Add labels to your project without updating the labeling configuration.

        Parameters:
            - request: typing.List[LabelCreate].
        ---
        from label-studio import LabelCreate, LabelCreateValue
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_labels_create(request=[LabelCreate(project=1, from_name="from_name", value=LabelCreateValue(), title="title", )], )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/labels/"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[LabelCreate], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_labels_bulk_create(self) -> None:
        """
        If you want to update the labels in saved annotations, use this endpoint.

        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_labels_bulk_create()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/labels/bulk"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_labels_read(self, id: str) -> Label:
        """
        Retrieve a specific custom label used for your project by its ID.

        Parameters:
            - id: str.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_labels_read(id="id", )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/labels/{id}/"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Label, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_labels_delete(self, id: str) -> None:
        """
        Remove labels from your project without updating the labeling configuration.

        Parameters:
            - id: str.
        ---
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_labels_delete(id="id", )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/labels/{id}/"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_labels_partial_update(self, id: str, *, request: Label) -> Label:
        """
        Update labels used for your project without updating the labeling configuration.

        Parameters:
            - id: str.

            - request: Label.
        ---
        from label-studio import Label, LabelValue
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.labels.api_labels_partial_update(id="id", request=Label(value=LabelValue(), title="title", created_by=1, organization=1, ), )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/labels/{id}/"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Label, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
