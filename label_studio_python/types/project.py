# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..core.datetime_utils import serialize_datetime
from .project_control_weights import ProjectControlWeights
from .project_sampling import ProjectSampling
from .project_skip_queue import ProjectSkipQueue
from .user_simple import UserSimple

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore


class Project(pydantic.BaseModel):
    id: typing.Optional[int]
    title: typing.Optional[str] = pydantic.Field(description="Project name. Must be between 3 and 50 characters long.")
    description: typing.Optional[str] = pydantic.Field(description="Project description")
    label_config: typing.Optional[str] = pydantic.Field(
        description="Label config in XML format. See more about it in documentation"
    )
    expert_instruction: typing.Optional[str] = pydantic.Field(description="Labeling instructions in HTML format")
    show_instruction: typing.Optional[bool] = pydantic.Field(
        description="Show instructions to the annotator before they start"
    )
    show_skip_button: typing.Optional[bool] = pydantic.Field(
        description="Show a skip button in interface and allow annotators to skip the task"
    )
    enable_empty_annotation: typing.Optional[bool] = pydantic.Field(
        description="Allow annotators to submit empty annotations"
    )
    show_annotation_history: typing.Optional[bool] = pydantic.Field(description="Show annotation history to annotator")
    organization: typing.Optional[int]
    color: typing.Optional[str]
    maximum_annotations: typing.Optional[int] = pydantic.Field(
        description="Maximum number of annotations for one task. If the number of annotations per task is equal or greater to this value, the task is completed (is_labeled=True)"
    )
    is_published: typing.Optional[bool] = pydantic.Field(
        description="Whether or not the project is published to annotators"
    )
    model_version: typing.Optional[str] = pydantic.Field(description="Machine learning model version")
    is_draft: typing.Optional[bool] = pydantic.Field(
        description="Whether or not the project is in the middle of being created"
    )
    created_by: typing.Optional[UserSimple]
    created_at: typing.Optional[dt.datetime]
    min_annotations_to_start_training: typing.Optional[int] = pydantic.Field(
        description="Minimum number of completed tasks after which model training is started"
    )
    start_training_on_annotation_update: typing.Optional[str] = pydantic.Field(
        description="Start model training after any annotations are submitted or updated"
    )
    show_collab_predictions: typing.Optional[bool] = pydantic.Field(
        description="If set, the annotator can view model predictions"
    )
    num_tasks_with_annotations: typing.Optional[int] = pydantic.Field(description="Tasks with annotations count")
    task_number: typing.Optional[int] = pydantic.Field(description="Total task number in project")
    useful_annotation_number: typing.Optional[int] = pydantic.Field(
        description="Useful annotation number in project not including skipped_annotations_number and ground_truth_number. Total annotations = annotation_number + skipped_annotations_number + ground_truth_number"
    )
    ground_truth_number: typing.Optional[int] = pydantic.Field(description="Honeypot annotation number in project")
    skipped_annotations_number: typing.Optional[int] = pydantic.Field(
        description="Skipped by collaborators annotation number in project"
    )
    total_annotations_number: typing.Optional[int] = pydantic.Field(
        description="Total annotations number in project including skipped_annotations_number and ground_truth_number."
    )
    total_predictions_number: typing.Optional[int] = pydantic.Field(
        description="Total predictions number in project including skipped_annotations_number, ground_truth_number, and useful_annotation_number."
    )
    sampling: typing.Optional[ProjectSampling]
    show_ground_truth_first: typing.Optional[bool]
    show_overlap_first: typing.Optional[bool]
    overlap_cohort_percentage: typing.Optional[int]
    task_data_login: typing.Optional[str] = pydantic.Field(description="Task data credentials: login")
    task_data_password: typing.Optional[str] = pydantic.Field(description="Task data credentials: password")
    control_weights: typing.Optional[ProjectControlWeights] = pydantic.Field(
        description="Dict of weights for each control tag in metric calculation. Each control tag (e.g. label or choice) will have it's own key in control weight dict with weight for each label and overall weight.For example, if bounding box annotation with control tag named my_bbox should be included with 0.33 weight in agreement calculation, and the first label Car should be twice more important than Airplaine, then you have to need the specify: {'my_bbox': {'type': 'RectangleLabels', 'labels': {'Car': 1.0, 'Airplaine': 0.5}, 'overall': 0.33}"
    )
    parsed_label_config: typing.Optional[typing.Dict[str, typing.Any]] = pydantic.Field(
        description="JSON-formatted labeling configuration"
    )
    evaluate_predictions_automatically: typing.Optional[bool] = pydantic.Field(
        description="Retrieve and display predictions when loading a task"
    )
    config_has_control_tags: typing.Optional[str] = pydantic.Field(
        description="Flag to detect is project ready for labeling"
    )
    skip_queue: typing.Optional[ProjectSkipQueue]
    reveal_preannotations_interactively: typing.Optional[bool] = pydantic.Field(
        description="Reveal pre-annotations interactively"
    )
    pinned_at: typing.Optional[dt.datetime] = pydantic.Field(description="Pinned date and time")
    finished_task_number: typing.Optional[int] = pydantic.Field(description="Finished tasks")
    queue_total: typing.Optional[str]
    queue_done: typing.Optional[str]

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
