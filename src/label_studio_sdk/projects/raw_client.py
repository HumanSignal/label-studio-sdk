# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..types.agreement_methodology_enum import AgreementMethodologyEnum
from ..types.all_roles_project_list import AllRolesProjectList
from ..types.assignment_settings_request import AssignmentSettingsRequest
from ..types.import_api_request import ImportApiRequest
from ..types.lse_project_create import LseProjectCreate
from ..types.lse_project_response import LseProjectResponse
from ..types.lse_project_update import LseProjectUpdate
from ..types.mode_enum import ModeEnum
from ..types.paginated_all_roles_project_list_list import PaginatedAllRolesProjectListList
from ..types.paginated_lse_project_counts_list import PaginatedLseProjectCountsList
from ..types.prediction_request import PredictionRequest
from ..types.project_label_config import ProjectLabelConfig
from ..types.review_settings_request import ReviewSettingsRequest
from ..types.sampling_de5enum import SamplingDe5Enum
from ..types.skip_queue_enum import SkipQueueEnum
from ..types.user_simple import UserSimple
from ..types.user_simple_request import UserSimpleRequest
from .types.duplicate_projects_response import DuplicateProjectsResponse
from .types.import_predictions_projects_response import ImportPredictionsProjectsResponse
from .types.import_tasks_projects_response import ImportTasksProjectsResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawProjectsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        filter: typing.Optional[str] = None,
        ids: typing.Optional[str] = None,
        include: typing.Optional[str] = None,
        members_limit: typing.Optional[int] = None,
        ordering: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        search: typing.Optional[str] = None,
        state: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        workspaces: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[AllRolesProjectList, PaginatedAllRolesProjectListList]:
        """
        Retrieve a list of projects.

        Parameters
        ----------
        filter : typing.Optional[str]
            Filter projects by pinned status. Use 'pinned_only' to return only pinned projects, 'exclude_pinned' to return only non-pinned projects, or 'all' to return all projects.

        ids : typing.Optional[str]
            Filter id by in list

        include : typing.Optional[str]
            Comma-separated list of count fields to include in the response to optimize performance. Available fields: task_number, finished_task_number, total_predictions_number, total_annotations_number, num_tasks_with_annotations, useful_annotation_number, ground_truth_number, skipped_annotations_number. If not specified, all count fields are included.

        members_limit : typing.Optional[int]
            Maximum number of members to return

        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        search : typing.Optional[str]
            Search term for project title and description

        state : typing.Optional[str]
            Filter current_state by exact match

        title : typing.Optional[str]
            Filter title by contains (case-insensitive)

        workspaces : typing.Optional[float]
            Filter workspaces by exact match

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[AllRolesProjectList, PaginatedAllRolesProjectListList]

        """
        page = page if page is not None else 1

        _response = self._client_wrapper.httpx_client.request(
            "api/projects/",
            method="GET",
            params={
                "filter": filter,
                "ids": ids,
                "include": include,
                "members_limit": members_limit,
                "ordering": ordering,
                "page": page,
                "page_size": page_size,
                "search": search,
                "state": state,
                "title": title,
                "workspaces": workspaces,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedAllRolesProjectListList,
                    construct_type(
                        type_=PaginatedAllRolesProjectListList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.results
                _has_next = True
                _get_next = lambda: self.list(
                    filter=filter,
                    ids=ids,
                    include=include,
                    members_limit=members_limit,
                    ordering=ordering,
                    page=page + 1,
                    page_size=page_size,
                    search=search,
                    state=state,
                    title=title,
                    workspaces=workspaces,
                    request_options=request_options,
                )
                return SyncPager(has_next=_has_next, items=_items, get_next=_get_next, response=_parsed_response)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        title: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        label_config: typing.Optional[str] = OMIT,
        expert_instruction: typing.Optional[str] = OMIT,
        show_instruction: typing.Optional[bool] = OMIT,
        show_skip_button: typing.Optional[bool] = OMIT,
        enable_empty_annotation: typing.Optional[bool] = OMIT,
        show_annotation_history: typing.Optional[bool] = OMIT,
        organization: typing.Optional[int] = OMIT,
        color: typing.Optional[str] = OMIT,
        maximum_annotations: typing.Optional[int] = OMIT,
        is_published: typing.Optional[bool] = OMIT,
        model_version: typing.Optional[str] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        created_by: typing.Optional[UserSimpleRequest] = OMIT,
        min_annotations_to_start_training: typing.Optional[int] = OMIT,
        show_collab_predictions: typing.Optional[bool] = OMIT,
        sampling: typing.Optional[SamplingDe5Enum] = OMIT,
        show_ground_truth_first: typing.Optional[bool] = OMIT,
        annotator_evaluation_enabled: typing.Optional[bool] = OMIT,
        show_overlap_first: typing.Optional[bool] = OMIT,
        overlap_cohort_percentage: typing.Optional[int] = OMIT,
        task_data_login: typing.Optional[str] = OMIT,
        task_data_password: typing.Optional[str] = OMIT,
        control_weights: typing.Optional[typing.Any] = OMIT,
        evaluate_predictions_automatically: typing.Optional[bool] = OMIT,
        skip_queue: typing.Optional[SkipQueueEnum] = OMIT,
        reveal_preannotations_interactively: typing.Optional[bool] = OMIT,
        pinned_at: typing.Optional[dt.datetime] = OMIT,
        workspace: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[LseProjectCreate]:
        """
        Create a project for a specific organization.

        Parameters
        ----------
        title : typing.Optional[str]
            Project name. Must be between 3 and 50 characters long.

        description : typing.Optional[str]
            Project description

        label_config : typing.Optional[str]
            Label config in XML format. See more about it in documentation

        expert_instruction : typing.Optional[str]
            Labeling instructions in HTML format

        show_instruction : typing.Optional[bool]
            Show instructions to the annotator before they start

        show_skip_button : typing.Optional[bool]
            Show a skip button in interface and allow annotators to skip the task

        enable_empty_annotation : typing.Optional[bool]
            Allow annotators to submit empty annotations

        show_annotation_history : typing.Optional[bool]
            Show annotation history to annotator

        organization : typing.Optional[int]

        color : typing.Optional[str]

        maximum_annotations : typing.Optional[int]
            Maximum number of annotations for one task. If the number of annotations per task is equal or greater to this value, the task is completed (is_labeled=True)

        is_published : typing.Optional[bool]
            Whether or not the project is published to annotators

        model_version : typing.Optional[str]
            Machine learning model version

        is_draft : typing.Optional[bool]
            Whether or not the project is in the middle of being created

        created_by : typing.Optional[UserSimpleRequest]
            Project owner

        min_annotations_to_start_training : typing.Optional[int]
            Minimum number of completed tasks after which model training is started

        show_collab_predictions : typing.Optional[bool]
            If set, the annotator can view model predictions

        sampling : typing.Optional[SamplingDe5Enum]

        show_ground_truth_first : typing.Optional[bool]
            Onboarding mode (true): show ground truth tasks first in the labeling stream

        annotator_evaluation_enabled : typing.Optional[bool]
            Enable annotator evaluation for the project

        show_overlap_first : typing.Optional[bool]

        overlap_cohort_percentage : typing.Optional[int]

        task_data_login : typing.Optional[str]
            Task data credentials: login

        task_data_password : typing.Optional[str]
            Task data credentials: password

        control_weights : typing.Optional[typing.Any]
            Dict of weights for each control tag in metric calculation. Each control tag (e.g. label or choice) will have it's own key in control weight dict with weight for each label and overall weight.For example, if bounding box annotation with control tag named my_bbox should be included with 0.33 weight in agreement calculation, and the first label Car should be twice more important than Airplaine, then you have to need the specify: {'my_bbox': {'type': 'RectangleLabels', 'labels': {'Car': 1.0, 'Airplaine': 0.5}, 'overall': 0.33}

        evaluate_predictions_automatically : typing.Optional[bool]
            Retrieve and display predictions when loading a task

        skip_queue : typing.Optional[SkipQueueEnum]

        reveal_preannotations_interactively : typing.Optional[bool]
            Reveal pre-annotations interactively

        pinned_at : typing.Optional[dt.datetime]
            Pinned date and time

        workspace : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[LseProjectCreate]

        """
        _response = self._client_wrapper.httpx_client.request(
            "api/projects/",
            method="POST",
            json={
                "title": title,
                "description": description,
                "label_config": label_config,
                "expert_instruction": expert_instruction,
                "show_instruction": show_instruction,
                "show_skip_button": show_skip_button,
                "enable_empty_annotation": enable_empty_annotation,
                "show_annotation_history": show_annotation_history,
                "organization": organization,
                "color": color,
                "maximum_annotations": maximum_annotations,
                "is_published": is_published,
                "model_version": model_version,
                "is_draft": is_draft,
                "created_by": convert_and_respect_annotation_metadata(
                    object_=created_by, annotation=UserSimpleRequest, direction="write"
                ),
                "min_annotations_to_start_training": min_annotations_to_start_training,
                "show_collab_predictions": show_collab_predictions,
                "sampling": sampling,
                "show_ground_truth_first": show_ground_truth_first,
                "annotator_evaluation_enabled": annotator_evaluation_enabled,
                "show_overlap_first": show_overlap_first,
                "overlap_cohort_percentage": overlap_cohort_percentage,
                "task_data_login": task_data_login,
                "task_data_password": task_data_password,
                "control_weights": control_weights,
                "evaluate_predictions_automatically": evaluate_predictions_automatically,
                "skip_queue": skip_queue,
                "reveal_preannotations_interactively": reveal_preannotations_interactively,
                "pinned_at": pinned_at,
                "workspace": workspace,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LseProjectCreate,
                    construct_type(
                        type_=LseProjectCreate,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(
        self,
        id: int,
        *,
        members_limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[LseProjectResponse]:
        """
        Retrieve information about a project by project ID.

        Parameters
        ----------
        id : int

        members_limit : typing.Optional[int]
            Maximum number of members to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[LseProjectResponse]
            Project information. Not all fields are available for all roles.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/",
            method="GET",
            params={
                "members_limit": members_limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LseProjectResponse,
                    construct_type(
                        type_=LseProjectResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(self, id: int, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Delete a project by specified project ID.

        Parameters
        ----------
        id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        id: int,
        *,
        members_limit: typing.Optional[int] = None,
        title: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        label_config: typing.Optional[str] = OMIT,
        expert_instruction: typing.Optional[str] = OMIT,
        show_instruction: typing.Optional[bool] = OMIT,
        show_skip_button: typing.Optional[bool] = OMIT,
        enable_empty_annotation: typing.Optional[bool] = OMIT,
        show_annotation_history: typing.Optional[bool] = OMIT,
        organization: typing.Optional[int] = OMIT,
        color: typing.Optional[str] = OMIT,
        maximum_annotations: typing.Optional[int] = OMIT,
        is_published: typing.Optional[bool] = OMIT,
        model_version: typing.Optional[str] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        created_by: typing.Optional[UserSimpleRequest] = OMIT,
        min_annotations_to_start_training: typing.Optional[int] = OMIT,
        show_collab_predictions: typing.Optional[bool] = OMIT,
        sampling: typing.Optional[SamplingDe5Enum] = OMIT,
        show_ground_truth_first: typing.Optional[bool] = OMIT,
        annotator_evaluation_enabled: typing.Optional[bool] = OMIT,
        show_overlap_first: typing.Optional[bool] = OMIT,
        overlap_cohort_percentage: typing.Optional[int] = OMIT,
        task_data_login: typing.Optional[str] = OMIT,
        task_data_password: typing.Optional[str] = OMIT,
        control_weights: typing.Optional[typing.Any] = OMIT,
        evaluate_predictions_automatically: typing.Optional[bool] = OMIT,
        skip_queue: typing.Optional[SkipQueueEnum] = OMIT,
        reveal_preannotations_interactively: typing.Optional[bool] = OMIT,
        pinned_at: typing.Optional[dt.datetime] = OMIT,
        workspace: typing.Optional[int] = OMIT,
        review_settings: typing.Optional[ReviewSettingsRequest] = OMIT,
        assignment_settings: typing.Optional[AssignmentSettingsRequest] = OMIT,
        agreement_methodology: typing.Optional[AgreementMethodologyEnum] = OMIT,
        custom_script: typing.Optional[str] = OMIT,
        comment_classification_config: typing.Optional[str] = OMIT,
        require_comment_on_skip: typing.Optional[bool] = OMIT,
        strict_task_overlap: typing.Optional[bool] = OMIT,
        show_unused_data_columns_to_annotators: typing.Optional[bool] = OMIT,
        custom_task_lock_ttl: typing.Optional[int] = OMIT,
        annotation_limit_count: typing.Optional[int] = OMIT,
        annotation_limit_percent: typing.Optional[str] = OMIT,
        pause_on_failed_annotator_evaluation: typing.Optional[bool] = OMIT,
        annotator_evaluation_minimum_score: typing.Optional[str] = OMIT,
        annotator_evaluation_minimum_tasks: typing.Optional[int] = OMIT,
        annotator_evaluation_onboarding_tasks: typing.Optional[int] = OMIT,
        agreement_threshold: typing.Optional[str] = OMIT,
        max_additional_annotators_assignable: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[LseProjectUpdate]:
        """
        Update the details of a specific project.

        Parameters
        ----------
        id : int

        members_limit : typing.Optional[int]
            Maximum number of members to return

        title : typing.Optional[str]
            Project name. Must be between 3 and 50 characters long.

        description : typing.Optional[str]
            Project description

        label_config : typing.Optional[str]
            Label config in XML format. See more about it in documentation

        expert_instruction : typing.Optional[str]
            Labeling instructions in HTML format

        show_instruction : typing.Optional[bool]
            Show instructions to the annotator before they start

        show_skip_button : typing.Optional[bool]
            Show a skip button in interface and allow annotators to skip the task

        enable_empty_annotation : typing.Optional[bool]
            Allow annotators to submit empty annotations

        show_annotation_history : typing.Optional[bool]
            Show annotation history to annotator

        organization : typing.Optional[int]

        color : typing.Optional[str]

        maximum_annotations : typing.Optional[int]
            Maximum number of annotations for one task. If the number of annotations per task is equal or greater to this value, the task is completed (is_labeled=True)

        is_published : typing.Optional[bool]
            Whether or not the project is published to annotators

        model_version : typing.Optional[str]
            Machine learning model version

        is_draft : typing.Optional[bool]
            Whether or not the project is in the middle of being created

        created_by : typing.Optional[UserSimpleRequest]
            Project owner

        min_annotations_to_start_training : typing.Optional[int]
            Minimum number of completed tasks after which model training is started

        show_collab_predictions : typing.Optional[bool]
            If set, the annotator can view model predictions

        sampling : typing.Optional[SamplingDe5Enum]

        show_ground_truth_first : typing.Optional[bool]
            Onboarding mode (true): show ground truth tasks first in the labeling stream

        annotator_evaluation_enabled : typing.Optional[bool]
            Enable annotator evaluation for the project

        show_overlap_first : typing.Optional[bool]

        overlap_cohort_percentage : typing.Optional[int]

        task_data_login : typing.Optional[str]
            Task data credentials: login

        task_data_password : typing.Optional[str]
            Task data credentials: password

        control_weights : typing.Optional[typing.Any]
            Dict of weights for each control tag in metric calculation. Each control tag (e.g. label or choice) will have it's own key in control weight dict with weight for each label and overall weight.For example, if bounding box annotation with control tag named my_bbox should be included with 0.33 weight in agreement calculation, and the first label Car should be twice more important than Airplaine, then you have to need the specify: {'my_bbox': {'type': 'RectangleLabels', 'labels': {'Car': 1.0, 'Airplaine': 0.5}, 'overall': 0.33}

        evaluate_predictions_automatically : typing.Optional[bool]
            Retrieve and display predictions when loading a task

        skip_queue : typing.Optional[SkipQueueEnum]

        reveal_preannotations_interactively : typing.Optional[bool]
            Reveal pre-annotations interactively

        pinned_at : typing.Optional[dt.datetime]
            Pinned date and time

        workspace : typing.Optional[int]

        review_settings : typing.Optional[ReviewSettingsRequest]

        assignment_settings : typing.Optional[AssignmentSettingsRequest]

        agreement_methodology : typing.Optional[AgreementMethodologyEnum]

        custom_script : typing.Optional[str]

        comment_classification_config : typing.Optional[str]

        require_comment_on_skip : typing.Optional[bool]

        strict_task_overlap : typing.Optional[bool]

        show_unused_data_columns_to_annotators : typing.Optional[bool]

        custom_task_lock_ttl : typing.Optional[int]
            TTL in seconds for task reservations, on new and existing tasks

        annotation_limit_count : typing.Optional[int]

        annotation_limit_percent : typing.Optional[str]

        pause_on_failed_annotator_evaluation : typing.Optional[bool]

        annotator_evaluation_minimum_score : typing.Optional[str]

        annotator_evaluation_minimum_tasks : typing.Optional[int]

        annotator_evaluation_onboarding_tasks : typing.Optional[int]

        agreement_threshold : typing.Optional[str]
            Minimum percent agreement threshold for which minimum number of annotators must agree

        max_additional_annotators_assignable : typing.Optional[int]
            Maximum number of additional annotators that can be assigned to a low agreement task

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[LseProjectUpdate]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/",
            method="PATCH",
            params={
                "members_limit": members_limit,
            },
            json={
                "title": title,
                "description": description,
                "label_config": label_config,
                "expert_instruction": expert_instruction,
                "show_instruction": show_instruction,
                "show_skip_button": show_skip_button,
                "enable_empty_annotation": enable_empty_annotation,
                "show_annotation_history": show_annotation_history,
                "organization": organization,
                "color": color,
                "maximum_annotations": maximum_annotations,
                "is_published": is_published,
                "model_version": model_version,
                "is_draft": is_draft,
                "created_by": convert_and_respect_annotation_metadata(
                    object_=created_by, annotation=UserSimpleRequest, direction="write"
                ),
                "min_annotations_to_start_training": min_annotations_to_start_training,
                "show_collab_predictions": show_collab_predictions,
                "sampling": sampling,
                "show_ground_truth_first": show_ground_truth_first,
                "annotator_evaluation_enabled": annotator_evaluation_enabled,
                "show_overlap_first": show_overlap_first,
                "overlap_cohort_percentage": overlap_cohort_percentage,
                "task_data_login": task_data_login,
                "task_data_password": task_data_password,
                "control_weights": control_weights,
                "evaluate_predictions_automatically": evaluate_predictions_automatically,
                "skip_queue": skip_queue,
                "reveal_preannotations_interactively": reveal_preannotations_interactively,
                "pinned_at": pinned_at,
                "workspace": workspace,
                "review_settings": convert_and_respect_annotation_metadata(
                    object_=review_settings, annotation=ReviewSettingsRequest, direction="write"
                ),
                "assignment_settings": convert_and_respect_annotation_metadata(
                    object_=assignment_settings, annotation=AssignmentSettingsRequest, direction="write"
                ),
                "agreement_methodology": agreement_methodology,
                "custom_script": custom_script,
                "comment_classification_config": comment_classification_config,
                "require_comment_on_skip": require_comment_on_skip,
                "strict_task_overlap": strict_task_overlap,
                "show_unused_data_columns_to_annotators": show_unused_data_columns_to_annotators,
                "custom_task_lock_ttl": custom_task_lock_ttl,
                "annotation_limit_count": annotation_limit_count,
                "annotation_limit_percent": annotation_limit_percent,
                "pause_on_failed_annotator_evaluation": pause_on_failed_annotator_evaluation,
                "annotator_evaluation_minimum_score": annotator_evaluation_minimum_score,
                "annotator_evaluation_minimum_tasks": annotator_evaluation_minimum_tasks,
                "annotator_evaluation_onboarding_tasks": annotator_evaluation_onboarding_tasks,
                "agreement_threshold": agreement_threshold,
                "max_additional_annotators_assignable": max_additional_annotators_assignable,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LseProjectUpdate,
                    construct_type(
                        type_=LseProjectUpdate,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_unique_annotators(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[UserSimple]]:
        """
        Return unique users who have submitted annotations in the specified project.

        Parameters
        ----------
        id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[UserSimple]]
            List of annotator users
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/annotators/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[UserSimple],
                    construct_type(
                        type_=typing.List[UserSimple],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def duplicate(
        self,
        id: int,
        *,
        mode: ModeEnum,
        workspace: int,
        title: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DuplicateProjectsResponse]:
        """
        <Card href="https://humansignal.com/goenterprise">
                <img style="pointer-events: none; margin-left: 0px; margin-right: 0px;" src="https://docs.humansignal.com/images/badge.svg" alt="Label Studio Enterprise badge"/>
                <p style="margin-top: 10px; font-size: 14px;">
                    This endpoint is not available in Label Studio Community Edition. [Learn more about Label Studio Enterprise](https://humansignal.com/goenterprise)
                </p>
            </Card>
        Make a copy of project.

        Parameters
        ----------
        id : int

        mode : ModeEnum
            Data that you want to duplicate: settings only, with tasks, with annotations

            * `settings` - Only settings
            * `settings,data` - Settings and tasks

        workspace : int
            Workspace, where to place duplicated project

        title : str
            Title of duplicated project

        description : typing.Optional[str]
            Description of duplicated project

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DuplicateProjectsResponse]
            Project duplicated
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/duplicate/",
            method="POST",
            json={
                "mode": mode,
                "workspace": workspace,
                "title": title,
                "description": description,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DuplicateProjectsResponse,
                    construct_type(
                        type_=DuplicateProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def import_tasks(
        self,
        id: int,
        *,
        request: typing.Sequence[ImportApiRequest],
        commit_to_project: typing.Optional[bool] = None,
        preannotated_from_fields: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        return_task_ids: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ImportTasksProjectsResponse]:
        """
        
                    Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
                    One POST request is limited at 250K tasks and 200 MB.
        
                    **Note:** Imported data is verified against a project *label_config* and must
                    include all variables that were used in the *label_config*. For example,
                    if the label configuration has a *$text* variable, then each item in a data object
                    must include a "text" field.
                    <br>
        
                    ## Async Import Behavior
                    <hr style="opacity:0.3">
        
                    **For non-Community editions, this endpoint processes imports asynchronously.**
                    
                    - The POST request **can fail** for invalid parameters, malformed request body, or other request-level validation errors.
                    - However, **data validation errors** that occur during import processing are handled asynchronously and will not cause the POST request to fail.
                    - Upon successful request validation, a response is returned: `{"import": <import_id>}`
                    - Use the returned `import_id` to poll the GET `/api/projects/{project_id}/imports/{import_id}` endpoint to check the import status and see any data validation errors.
                    - Data-level errors and import failures will only be visible in the GET request response.
        
                    For Community edition, imports are processed synchronously and return task counts immediately.
                    <br>
        
                    ## POST requests
                    <hr style="opacity:0.3">
        
                    There are three possible ways to import tasks with this endpoint:
        
                    ### 1. **POST with data**
                    Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
                    Update this example to specify your authorization token and Label Studio instance host, then run the following from
                    the command line.
        
                    ```bash
                    curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \\
                    -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
                    ```
        
                    ### 2. **POST with files**
                    Send tasks as files. You can attach multiple files with different names.
        
                    - **JSON**: text files in JavaScript object notation format
                    - **CSV**: text files with tables in Comma Separated Values format
                    - **TSV**: text files with tables in Tab Separated Value format
                    - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
                    Update this example to specify your authorization token, Label Studio instance host, and file name and path,
                    then run the following from the command line:
        
                    ```bash
                    curl -H 'Authorization: Token abc123' \\
                    -X POST 'https://localhost:8080/api/projects/1/import' -F 'file=@path/to/my_file.csv'
                    ```
        
                    ### 3. **POST with URL**
                    You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
                    ```bash
                    curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \\
                    -X POST 'https://localhost:8080/api/projects/1/import' \\
                    --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
                    ```
        
                    <br>
                
        
        Parameters
        ----------
        id : int
            A unique integer value identifying this project.
        
        request : typing.Sequence[ImportApiRequest]
        
        commit_to_project : typing.Optional[bool]
            Set to "true" to immediately commit tasks to the project.
        
        preannotated_from_fields : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            List of fields to preannotate from the task data. For example, if you provide a list of `{"text": "text", "prediction": "label"}` items in the request, the system will create a task with the `text` field and a prediction with the `label` field when `preannoted_from_fields=["prediction"]`.
        
        return_task_ids : typing.Optional[bool]
            Set to "true" to return task IDs in the response.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        HttpResponse[ImportTasksProjectsResponse]
            Tasks successfully imported or import queued. **For non-Community editions**, the response will be `{"import": <import_id>}` which you can use to poll the import status. **For Community edition**, the response contains task counts and is processed synchronously.
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/import",
            method="POST",
            params={
                "commit_to_project": commit_to_project,
                "preannotated_from_fields": preannotated_from_fields,
                "return_task_ids": return_task_ids,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[ImportApiRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ImportTasksProjectsResponse,
                    construct_type(
                        type_=ImportTasksProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def import_predictions(
        self,
        id: int,
        *,
        request: typing.Sequence[PredictionRequest],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ImportPredictionsProjectsResponse]:
        """
        Import model predictions for tasks in the specified project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request : typing.Sequence[PredictionRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ImportPredictionsProjectsResponse]
            Predictions successfully imported
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/import/predictions",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[PredictionRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ImportPredictionsProjectsResponse,
                    construct_type(
                        type_=ImportPredictionsProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def validate_label_config(
        self, id: int, *, label_config: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ProjectLabelConfig]:
        """
        Determine whether the label configuration for a specific project is valid.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        label_config : str
            Label config in XML format. See more about it in documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ProjectLabelConfig]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/validate/",
            method="POST",
            json={
                "label_config": label_config,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProjectLabelConfig,
                    construct_type(
                        type_=ProjectLabelConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_counts(
        self,
        *,
        filter: typing.Optional[str] = None,
        ids: typing.Optional[str] = None,
        include: typing.Optional[str] = None,
        ordering: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        search: typing.Optional[str] = None,
        state: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        workspaces: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PaginatedLseProjectCountsList]:
        """
        Returns a list of projects with their counts. For example, task_number which is the total task number in project

        Parameters
        ----------
        filter : typing.Optional[str]
            Filter projects by pinned status. Use 'pinned_only' to return only pinned projects, 'exclude_pinned' to return only non-pinned projects, or 'all' to return all projects.

        ids : typing.Optional[str]
            Filter id by in list

        include : typing.Optional[str]
            Comma-separated list of count fields to include in the response to optimize performance. Available fields: task_number, finished_task_number, total_predictions_number, total_annotations_number, num_tasks_with_annotations, useful_annotation_number, ground_truth_number, skipped_annotations_number. If not specified, all count fields are included.

        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        search : typing.Optional[str]
            Search term for project title and description

        state : typing.Optional[str]
            Filter current_state by exact match

        title : typing.Optional[str]
            Filter title by contains (case-insensitive)

        workspaces : typing.Optional[float]
            Filter workspaces by exact match

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PaginatedLseProjectCountsList]

        """
        _response = self._client_wrapper.httpx_client.request(
            "api/projects/counts/",
            method="GET",
            params={
                "filter": filter,
                "ids": ids,
                "include": include,
                "ordering": ordering,
                "page": page,
                "page_size": page_size,
                "search": search,
                "state": state,
                "title": title,
                "workspaces": workspaces,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedLseProjectCountsList,
                    construct_type(
                        type_=PaginatedLseProjectCountsList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawProjectsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        filter: typing.Optional[str] = None,
        ids: typing.Optional[str] = None,
        include: typing.Optional[str] = None,
        members_limit: typing.Optional[int] = None,
        ordering: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        search: typing.Optional[str] = None,
        state: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        workspaces: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[AllRolesProjectList, PaginatedAllRolesProjectListList]:
        """
        Retrieve a list of projects.

        Parameters
        ----------
        filter : typing.Optional[str]
            Filter projects by pinned status. Use 'pinned_only' to return only pinned projects, 'exclude_pinned' to return only non-pinned projects, or 'all' to return all projects.

        ids : typing.Optional[str]
            Filter id by in list

        include : typing.Optional[str]
            Comma-separated list of count fields to include in the response to optimize performance. Available fields: task_number, finished_task_number, total_predictions_number, total_annotations_number, num_tasks_with_annotations, useful_annotation_number, ground_truth_number, skipped_annotations_number. If not specified, all count fields are included.

        members_limit : typing.Optional[int]
            Maximum number of members to return

        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        search : typing.Optional[str]
            Search term for project title and description

        state : typing.Optional[str]
            Filter current_state by exact match

        title : typing.Optional[str]
            Filter title by contains (case-insensitive)

        workspaces : typing.Optional[float]
            Filter workspaces by exact match

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[AllRolesProjectList, PaginatedAllRolesProjectListList]

        """
        page = page if page is not None else 1

        _response = await self._client_wrapper.httpx_client.request(
            "api/projects/",
            method="GET",
            params={
                "filter": filter,
                "ids": ids,
                "include": include,
                "members_limit": members_limit,
                "ordering": ordering,
                "page": page,
                "page_size": page_size,
                "search": search,
                "state": state,
                "title": title,
                "workspaces": workspaces,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedAllRolesProjectListList,
                    construct_type(
                        type_=PaginatedAllRolesProjectListList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.results
                _has_next = True

                async def _get_next():
                    return await self.list(
                        filter=filter,
                        ids=ids,
                        include=include,
                        members_limit=members_limit,
                        ordering=ordering,
                        page=page + 1,
                        page_size=page_size,
                        search=search,
                        state=state,
                        title=title,
                        workspaces=workspaces,
                        request_options=request_options,
                    )

                return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next, response=_parsed_response)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        title: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        label_config: typing.Optional[str] = OMIT,
        expert_instruction: typing.Optional[str] = OMIT,
        show_instruction: typing.Optional[bool] = OMIT,
        show_skip_button: typing.Optional[bool] = OMIT,
        enable_empty_annotation: typing.Optional[bool] = OMIT,
        show_annotation_history: typing.Optional[bool] = OMIT,
        organization: typing.Optional[int] = OMIT,
        color: typing.Optional[str] = OMIT,
        maximum_annotations: typing.Optional[int] = OMIT,
        is_published: typing.Optional[bool] = OMIT,
        model_version: typing.Optional[str] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        created_by: typing.Optional[UserSimpleRequest] = OMIT,
        min_annotations_to_start_training: typing.Optional[int] = OMIT,
        show_collab_predictions: typing.Optional[bool] = OMIT,
        sampling: typing.Optional[SamplingDe5Enum] = OMIT,
        show_ground_truth_first: typing.Optional[bool] = OMIT,
        annotator_evaluation_enabled: typing.Optional[bool] = OMIT,
        show_overlap_first: typing.Optional[bool] = OMIT,
        overlap_cohort_percentage: typing.Optional[int] = OMIT,
        task_data_login: typing.Optional[str] = OMIT,
        task_data_password: typing.Optional[str] = OMIT,
        control_weights: typing.Optional[typing.Any] = OMIT,
        evaluate_predictions_automatically: typing.Optional[bool] = OMIT,
        skip_queue: typing.Optional[SkipQueueEnum] = OMIT,
        reveal_preannotations_interactively: typing.Optional[bool] = OMIT,
        pinned_at: typing.Optional[dt.datetime] = OMIT,
        workspace: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[LseProjectCreate]:
        """
        Create a project for a specific organization.

        Parameters
        ----------
        title : typing.Optional[str]
            Project name. Must be between 3 and 50 characters long.

        description : typing.Optional[str]
            Project description

        label_config : typing.Optional[str]
            Label config in XML format. See more about it in documentation

        expert_instruction : typing.Optional[str]
            Labeling instructions in HTML format

        show_instruction : typing.Optional[bool]
            Show instructions to the annotator before they start

        show_skip_button : typing.Optional[bool]
            Show a skip button in interface and allow annotators to skip the task

        enable_empty_annotation : typing.Optional[bool]
            Allow annotators to submit empty annotations

        show_annotation_history : typing.Optional[bool]
            Show annotation history to annotator

        organization : typing.Optional[int]

        color : typing.Optional[str]

        maximum_annotations : typing.Optional[int]
            Maximum number of annotations for one task. If the number of annotations per task is equal or greater to this value, the task is completed (is_labeled=True)

        is_published : typing.Optional[bool]
            Whether or not the project is published to annotators

        model_version : typing.Optional[str]
            Machine learning model version

        is_draft : typing.Optional[bool]
            Whether or not the project is in the middle of being created

        created_by : typing.Optional[UserSimpleRequest]
            Project owner

        min_annotations_to_start_training : typing.Optional[int]
            Minimum number of completed tasks after which model training is started

        show_collab_predictions : typing.Optional[bool]
            If set, the annotator can view model predictions

        sampling : typing.Optional[SamplingDe5Enum]

        show_ground_truth_first : typing.Optional[bool]
            Onboarding mode (true): show ground truth tasks first in the labeling stream

        annotator_evaluation_enabled : typing.Optional[bool]
            Enable annotator evaluation for the project

        show_overlap_first : typing.Optional[bool]

        overlap_cohort_percentage : typing.Optional[int]

        task_data_login : typing.Optional[str]
            Task data credentials: login

        task_data_password : typing.Optional[str]
            Task data credentials: password

        control_weights : typing.Optional[typing.Any]
            Dict of weights for each control tag in metric calculation. Each control tag (e.g. label or choice) will have it's own key in control weight dict with weight for each label and overall weight.For example, if bounding box annotation with control tag named my_bbox should be included with 0.33 weight in agreement calculation, and the first label Car should be twice more important than Airplaine, then you have to need the specify: {'my_bbox': {'type': 'RectangleLabels', 'labels': {'Car': 1.0, 'Airplaine': 0.5}, 'overall': 0.33}

        evaluate_predictions_automatically : typing.Optional[bool]
            Retrieve and display predictions when loading a task

        skip_queue : typing.Optional[SkipQueueEnum]

        reveal_preannotations_interactively : typing.Optional[bool]
            Reveal pre-annotations interactively

        pinned_at : typing.Optional[dt.datetime]
            Pinned date and time

        workspace : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[LseProjectCreate]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/projects/",
            method="POST",
            json={
                "title": title,
                "description": description,
                "label_config": label_config,
                "expert_instruction": expert_instruction,
                "show_instruction": show_instruction,
                "show_skip_button": show_skip_button,
                "enable_empty_annotation": enable_empty_annotation,
                "show_annotation_history": show_annotation_history,
                "organization": organization,
                "color": color,
                "maximum_annotations": maximum_annotations,
                "is_published": is_published,
                "model_version": model_version,
                "is_draft": is_draft,
                "created_by": convert_and_respect_annotation_metadata(
                    object_=created_by, annotation=UserSimpleRequest, direction="write"
                ),
                "min_annotations_to_start_training": min_annotations_to_start_training,
                "show_collab_predictions": show_collab_predictions,
                "sampling": sampling,
                "show_ground_truth_first": show_ground_truth_first,
                "annotator_evaluation_enabled": annotator_evaluation_enabled,
                "show_overlap_first": show_overlap_first,
                "overlap_cohort_percentage": overlap_cohort_percentage,
                "task_data_login": task_data_login,
                "task_data_password": task_data_password,
                "control_weights": control_weights,
                "evaluate_predictions_automatically": evaluate_predictions_automatically,
                "skip_queue": skip_queue,
                "reveal_preannotations_interactively": reveal_preannotations_interactively,
                "pinned_at": pinned_at,
                "workspace": workspace,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LseProjectCreate,
                    construct_type(
                        type_=LseProjectCreate,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self,
        id: int,
        *,
        members_limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[LseProjectResponse]:
        """
        Retrieve information about a project by project ID.

        Parameters
        ----------
        id : int

        members_limit : typing.Optional[int]
            Maximum number of members to return

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[LseProjectResponse]
            Project information. Not all fields are available for all roles.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/",
            method="GET",
            params={
                "members_limit": members_limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LseProjectResponse,
                    construct_type(
                        type_=LseProjectResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete a project by specified project ID.

        Parameters
        ----------
        id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        id: int,
        *,
        members_limit: typing.Optional[int] = None,
        title: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        label_config: typing.Optional[str] = OMIT,
        expert_instruction: typing.Optional[str] = OMIT,
        show_instruction: typing.Optional[bool] = OMIT,
        show_skip_button: typing.Optional[bool] = OMIT,
        enable_empty_annotation: typing.Optional[bool] = OMIT,
        show_annotation_history: typing.Optional[bool] = OMIT,
        organization: typing.Optional[int] = OMIT,
        color: typing.Optional[str] = OMIT,
        maximum_annotations: typing.Optional[int] = OMIT,
        is_published: typing.Optional[bool] = OMIT,
        model_version: typing.Optional[str] = OMIT,
        is_draft: typing.Optional[bool] = OMIT,
        created_by: typing.Optional[UserSimpleRequest] = OMIT,
        min_annotations_to_start_training: typing.Optional[int] = OMIT,
        show_collab_predictions: typing.Optional[bool] = OMIT,
        sampling: typing.Optional[SamplingDe5Enum] = OMIT,
        show_ground_truth_first: typing.Optional[bool] = OMIT,
        annotator_evaluation_enabled: typing.Optional[bool] = OMIT,
        show_overlap_first: typing.Optional[bool] = OMIT,
        overlap_cohort_percentage: typing.Optional[int] = OMIT,
        task_data_login: typing.Optional[str] = OMIT,
        task_data_password: typing.Optional[str] = OMIT,
        control_weights: typing.Optional[typing.Any] = OMIT,
        evaluate_predictions_automatically: typing.Optional[bool] = OMIT,
        skip_queue: typing.Optional[SkipQueueEnum] = OMIT,
        reveal_preannotations_interactively: typing.Optional[bool] = OMIT,
        pinned_at: typing.Optional[dt.datetime] = OMIT,
        workspace: typing.Optional[int] = OMIT,
        review_settings: typing.Optional[ReviewSettingsRequest] = OMIT,
        assignment_settings: typing.Optional[AssignmentSettingsRequest] = OMIT,
        agreement_methodology: typing.Optional[AgreementMethodologyEnum] = OMIT,
        custom_script: typing.Optional[str] = OMIT,
        comment_classification_config: typing.Optional[str] = OMIT,
        require_comment_on_skip: typing.Optional[bool] = OMIT,
        strict_task_overlap: typing.Optional[bool] = OMIT,
        show_unused_data_columns_to_annotators: typing.Optional[bool] = OMIT,
        custom_task_lock_ttl: typing.Optional[int] = OMIT,
        annotation_limit_count: typing.Optional[int] = OMIT,
        annotation_limit_percent: typing.Optional[str] = OMIT,
        pause_on_failed_annotator_evaluation: typing.Optional[bool] = OMIT,
        annotator_evaluation_minimum_score: typing.Optional[str] = OMIT,
        annotator_evaluation_minimum_tasks: typing.Optional[int] = OMIT,
        annotator_evaluation_onboarding_tasks: typing.Optional[int] = OMIT,
        agreement_threshold: typing.Optional[str] = OMIT,
        max_additional_annotators_assignable: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[LseProjectUpdate]:
        """
        Update the details of a specific project.

        Parameters
        ----------
        id : int

        members_limit : typing.Optional[int]
            Maximum number of members to return

        title : typing.Optional[str]
            Project name. Must be between 3 and 50 characters long.

        description : typing.Optional[str]
            Project description

        label_config : typing.Optional[str]
            Label config in XML format. See more about it in documentation

        expert_instruction : typing.Optional[str]
            Labeling instructions in HTML format

        show_instruction : typing.Optional[bool]
            Show instructions to the annotator before they start

        show_skip_button : typing.Optional[bool]
            Show a skip button in interface and allow annotators to skip the task

        enable_empty_annotation : typing.Optional[bool]
            Allow annotators to submit empty annotations

        show_annotation_history : typing.Optional[bool]
            Show annotation history to annotator

        organization : typing.Optional[int]

        color : typing.Optional[str]

        maximum_annotations : typing.Optional[int]
            Maximum number of annotations for one task. If the number of annotations per task is equal or greater to this value, the task is completed (is_labeled=True)

        is_published : typing.Optional[bool]
            Whether or not the project is published to annotators

        model_version : typing.Optional[str]
            Machine learning model version

        is_draft : typing.Optional[bool]
            Whether or not the project is in the middle of being created

        created_by : typing.Optional[UserSimpleRequest]
            Project owner

        min_annotations_to_start_training : typing.Optional[int]
            Minimum number of completed tasks after which model training is started

        show_collab_predictions : typing.Optional[bool]
            If set, the annotator can view model predictions

        sampling : typing.Optional[SamplingDe5Enum]

        show_ground_truth_first : typing.Optional[bool]
            Onboarding mode (true): show ground truth tasks first in the labeling stream

        annotator_evaluation_enabled : typing.Optional[bool]
            Enable annotator evaluation for the project

        show_overlap_first : typing.Optional[bool]

        overlap_cohort_percentage : typing.Optional[int]

        task_data_login : typing.Optional[str]
            Task data credentials: login

        task_data_password : typing.Optional[str]
            Task data credentials: password

        control_weights : typing.Optional[typing.Any]
            Dict of weights for each control tag in metric calculation. Each control tag (e.g. label or choice) will have it's own key in control weight dict with weight for each label and overall weight.For example, if bounding box annotation with control tag named my_bbox should be included with 0.33 weight in agreement calculation, and the first label Car should be twice more important than Airplaine, then you have to need the specify: {'my_bbox': {'type': 'RectangleLabels', 'labels': {'Car': 1.0, 'Airplaine': 0.5}, 'overall': 0.33}

        evaluate_predictions_automatically : typing.Optional[bool]
            Retrieve and display predictions when loading a task

        skip_queue : typing.Optional[SkipQueueEnum]

        reveal_preannotations_interactively : typing.Optional[bool]
            Reveal pre-annotations interactively

        pinned_at : typing.Optional[dt.datetime]
            Pinned date and time

        workspace : typing.Optional[int]

        review_settings : typing.Optional[ReviewSettingsRequest]

        assignment_settings : typing.Optional[AssignmentSettingsRequest]

        agreement_methodology : typing.Optional[AgreementMethodologyEnum]

        custom_script : typing.Optional[str]

        comment_classification_config : typing.Optional[str]

        require_comment_on_skip : typing.Optional[bool]

        strict_task_overlap : typing.Optional[bool]

        show_unused_data_columns_to_annotators : typing.Optional[bool]

        custom_task_lock_ttl : typing.Optional[int]
            TTL in seconds for task reservations, on new and existing tasks

        annotation_limit_count : typing.Optional[int]

        annotation_limit_percent : typing.Optional[str]

        pause_on_failed_annotator_evaluation : typing.Optional[bool]

        annotator_evaluation_minimum_score : typing.Optional[str]

        annotator_evaluation_minimum_tasks : typing.Optional[int]

        annotator_evaluation_onboarding_tasks : typing.Optional[int]

        agreement_threshold : typing.Optional[str]
            Minimum percent agreement threshold for which minimum number of annotators must agree

        max_additional_annotators_assignable : typing.Optional[int]
            Maximum number of additional annotators that can be assigned to a low agreement task

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[LseProjectUpdate]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/",
            method="PATCH",
            params={
                "members_limit": members_limit,
            },
            json={
                "title": title,
                "description": description,
                "label_config": label_config,
                "expert_instruction": expert_instruction,
                "show_instruction": show_instruction,
                "show_skip_button": show_skip_button,
                "enable_empty_annotation": enable_empty_annotation,
                "show_annotation_history": show_annotation_history,
                "organization": organization,
                "color": color,
                "maximum_annotations": maximum_annotations,
                "is_published": is_published,
                "model_version": model_version,
                "is_draft": is_draft,
                "created_by": convert_and_respect_annotation_metadata(
                    object_=created_by, annotation=UserSimpleRequest, direction="write"
                ),
                "min_annotations_to_start_training": min_annotations_to_start_training,
                "show_collab_predictions": show_collab_predictions,
                "sampling": sampling,
                "show_ground_truth_first": show_ground_truth_first,
                "annotator_evaluation_enabled": annotator_evaluation_enabled,
                "show_overlap_first": show_overlap_first,
                "overlap_cohort_percentage": overlap_cohort_percentage,
                "task_data_login": task_data_login,
                "task_data_password": task_data_password,
                "control_weights": control_weights,
                "evaluate_predictions_automatically": evaluate_predictions_automatically,
                "skip_queue": skip_queue,
                "reveal_preannotations_interactively": reveal_preannotations_interactively,
                "pinned_at": pinned_at,
                "workspace": workspace,
                "review_settings": convert_and_respect_annotation_metadata(
                    object_=review_settings, annotation=ReviewSettingsRequest, direction="write"
                ),
                "assignment_settings": convert_and_respect_annotation_metadata(
                    object_=assignment_settings, annotation=AssignmentSettingsRequest, direction="write"
                ),
                "agreement_methodology": agreement_methodology,
                "custom_script": custom_script,
                "comment_classification_config": comment_classification_config,
                "require_comment_on_skip": require_comment_on_skip,
                "strict_task_overlap": strict_task_overlap,
                "show_unused_data_columns_to_annotators": show_unused_data_columns_to_annotators,
                "custom_task_lock_ttl": custom_task_lock_ttl,
                "annotation_limit_count": annotation_limit_count,
                "annotation_limit_percent": annotation_limit_percent,
                "pause_on_failed_annotator_evaluation": pause_on_failed_annotator_evaluation,
                "annotator_evaluation_minimum_score": annotator_evaluation_minimum_score,
                "annotator_evaluation_minimum_tasks": annotator_evaluation_minimum_tasks,
                "annotator_evaluation_onboarding_tasks": annotator_evaluation_onboarding_tasks,
                "agreement_threshold": agreement_threshold,
                "max_additional_annotators_assignable": max_additional_annotators_assignable,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LseProjectUpdate,
                    construct_type(
                        type_=LseProjectUpdate,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_unique_annotators(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[UserSimple]]:
        """
        Return unique users who have submitted annotations in the specified project.

        Parameters
        ----------
        id : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[UserSimple]]
            List of annotator users
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/annotators/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[UserSimple],
                    construct_type(
                        type_=typing.List[UserSimple],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def duplicate(
        self,
        id: int,
        *,
        mode: ModeEnum,
        workspace: int,
        title: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DuplicateProjectsResponse]:
        """
        <Card href="https://humansignal.com/goenterprise">
                <img style="pointer-events: none; margin-left: 0px; margin-right: 0px;" src="https://docs.humansignal.com/images/badge.svg" alt="Label Studio Enterprise badge"/>
                <p style="margin-top: 10px; font-size: 14px;">
                    This endpoint is not available in Label Studio Community Edition. [Learn more about Label Studio Enterprise](https://humansignal.com/goenterprise)
                </p>
            </Card>
        Make a copy of project.

        Parameters
        ----------
        id : int

        mode : ModeEnum
            Data that you want to duplicate: settings only, with tasks, with annotations

            * `settings` - Only settings
            * `settings,data` - Settings and tasks

        workspace : int
            Workspace, where to place duplicated project

        title : str
            Title of duplicated project

        description : typing.Optional[str]
            Description of duplicated project

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DuplicateProjectsResponse]
            Project duplicated
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/duplicate/",
            method="POST",
            json={
                "mode": mode,
                "workspace": workspace,
                "title": title,
                "description": description,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DuplicateProjectsResponse,
                    construct_type(
                        type_=DuplicateProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def import_tasks(
        self,
        id: int,
        *,
        request: typing.Sequence[ImportApiRequest],
        commit_to_project: typing.Optional[bool] = None,
        preannotated_from_fields: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        return_task_ids: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ImportTasksProjectsResponse]:
        """
        
                    Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
                    One POST request is limited at 250K tasks and 200 MB.
        
                    **Note:** Imported data is verified against a project *label_config* and must
                    include all variables that were used in the *label_config*. For example,
                    if the label configuration has a *$text* variable, then each item in a data object
                    must include a "text" field.
                    <br>
        
                    ## Async Import Behavior
                    <hr style="opacity:0.3">
        
                    **For non-Community editions, this endpoint processes imports asynchronously.**
                    
                    - The POST request **can fail** for invalid parameters, malformed request body, or other request-level validation errors.
                    - However, **data validation errors** that occur during import processing are handled asynchronously and will not cause the POST request to fail.
                    - Upon successful request validation, a response is returned: `{"import": <import_id>}`
                    - Use the returned `import_id` to poll the GET `/api/projects/{project_id}/imports/{import_id}` endpoint to check the import status and see any data validation errors.
                    - Data-level errors and import failures will only be visible in the GET request response.
        
                    For Community edition, imports are processed synchronously and return task counts immediately.
                    <br>
        
                    ## POST requests
                    <hr style="opacity:0.3">
        
                    There are three possible ways to import tasks with this endpoint:
        
                    ### 1. **POST with data**
                    Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
                    Update this example to specify your authorization token and Label Studio instance host, then run the following from
                    the command line.
        
                    ```bash
                    curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \\
                    -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
                    ```
        
                    ### 2. **POST with files**
                    Send tasks as files. You can attach multiple files with different names.
        
                    - **JSON**: text files in JavaScript object notation format
                    - **CSV**: text files with tables in Comma Separated Values format
                    - **TSV**: text files with tables in Tab Separated Value format
                    - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
                    Update this example to specify your authorization token, Label Studio instance host, and file name and path,
                    then run the following from the command line:
        
                    ```bash
                    curl -H 'Authorization: Token abc123' \\
                    -X POST 'https://localhost:8080/api/projects/1/import' -F 'file=@path/to/my_file.csv'
                    ```
        
                    ### 3. **POST with URL**
                    You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
                    ```bash
                    curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \\
                    -X POST 'https://localhost:8080/api/projects/1/import' \\
                    --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
                    ```
        
                    <br>
                
        
        Parameters
        ----------
        id : int
            A unique integer value identifying this project.
        
        request : typing.Sequence[ImportApiRequest]
        
        commit_to_project : typing.Optional[bool]
            Set to "true" to immediately commit tasks to the project.
        
        preannotated_from_fields : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            List of fields to preannotate from the task data. For example, if you provide a list of `{"text": "text", "prediction": "label"}` items in the request, the system will create a task with the `text` field and a prediction with the `label` field when `preannoted_from_fields=["prediction"]`.
        
        return_task_ids : typing.Optional[bool]
            Set to "true" to return task IDs in the response.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        AsyncHttpResponse[ImportTasksProjectsResponse]
            Tasks successfully imported or import queued. **For non-Community editions**, the response will be `{"import": <import_id>}` which you can use to poll the import status. **For Community edition**, the response contains task counts and is processed synchronously.
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/import",
            method="POST",
            params={
                "commit_to_project": commit_to_project,
                "preannotated_from_fields": preannotated_from_fields,
                "return_task_ids": return_task_ids,
            },
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[ImportApiRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ImportTasksProjectsResponse,
                    construct_type(
                        type_=ImportTasksProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def import_predictions(
        self,
        id: int,
        *,
        request: typing.Sequence[PredictionRequest],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ImportPredictionsProjectsResponse]:
        """
        Import model predictions for tasks in the specified project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request : typing.Sequence[PredictionRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ImportPredictionsProjectsResponse]
            Predictions successfully imported
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/import/predictions",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=typing.Sequence[PredictionRequest], direction="write"
            ),
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ImportPredictionsProjectsResponse,
                    construct_type(
                        type_=ImportPredictionsProjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def validate_label_config(
        self, id: int, *, label_config: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ProjectLabelConfig]:
        """
        Determine whether the label configuration for a specific project is valid.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        label_config : str
            Label config in XML format. See more about it in documentation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ProjectLabelConfig]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/validate/",
            method="POST",
            json={
                "label_config": label_config,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProjectLabelConfig,
                    construct_type(
                        type_=ProjectLabelConfig,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_counts(
        self,
        *,
        filter: typing.Optional[str] = None,
        ids: typing.Optional[str] = None,
        include: typing.Optional[str] = None,
        ordering: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        search: typing.Optional[str] = None,
        state: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        workspaces: typing.Optional[float] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PaginatedLseProjectCountsList]:
        """
        Returns a list of projects with their counts. For example, task_number which is the total task number in project

        Parameters
        ----------
        filter : typing.Optional[str]
            Filter projects by pinned status. Use 'pinned_only' to return only pinned projects, 'exclude_pinned' to return only non-pinned projects, or 'all' to return all projects.

        ids : typing.Optional[str]
            Filter id by in list

        include : typing.Optional[str]
            Comma-separated list of count fields to include in the response to optimize performance. Available fields: task_number, finished_task_number, total_predictions_number, total_annotations_number, num_tasks_with_annotations, useful_annotation_number, ground_truth_number, skipped_annotations_number. If not specified, all count fields are included.

        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        search : typing.Optional[str]
            Search term for project title and description

        state : typing.Optional[str]
            Filter current_state by exact match

        title : typing.Optional[str]
            Filter title by contains (case-insensitive)

        workspaces : typing.Optional[float]
            Filter workspaces by exact match

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PaginatedLseProjectCountsList]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/projects/counts/",
            method="GET",
            params={
                "filter": filter,
                "ids": ids,
                "include": include,
                "ordering": ordering,
                "page": page,
                "page_size": page_size,
                "search": search,
                "state": state,
                "title": title,
                "workspaces": workspaces,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PaginatedLseProjectCountsList,
                    construct_type(
                        type_=PaginatedLseProjectCountsList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
