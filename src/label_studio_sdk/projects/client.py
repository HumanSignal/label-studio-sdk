# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.pydantic_utilities import pydantic_v1
from ..core.query_encoder import encode_query
from ..core.remove_none_from_dict import remove_none_from_dict
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..types.annotation import Annotation
from ..types.prediction import Prediction
from ..types.project import Project
from ..types.project_import import ProjectImport
from ..types.project_label_config import ProjectLabelConfig
from ..types.project_reimport import ProjectReimport
from .types.projects_get_many_response import ProjectsGetManyResponse
from .types.projects_import_tasks_response import ProjectsImportTasksResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProjectsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_many(
        self,
        *,
        ordering: typing.Optional[str] = None,
        ids: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[Project]:
        """
        Return a list of the projects that you've created.

        To perform most tasks with the Label Studio API, you must specify the project ID, sometimes referred to as the `pk`.
        To retrieve a list of your Label Studio projects, update the following command to match your own environment.
        Replace the domain name, port, and authorization token, then run the following from the command line:

        ```bash
        curl -X GET https://localhost:8080/api/projects/ -H 'Authorization: Token abc123'
        ```

        Parameters
        ----------
        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        ids : typing.Optional[str]
            ids

        title : typing.Optional[str]
            title

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[Project]


        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.get_many()
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/projects/"),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        {
                            "ordering": ordering,
                            "ids": ids,
                            "title": title,
                            "page": page,
                            "page_size": page_size,
                            **(
                                request_options.get("additional_query_parameters", {})
                                if request_options is not None
                                else {}
                            ),
                        }
                    )
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic_v1.parse_obj_as(ProjectsGetManyResponse, _response.json())  # type: ignore
            _has_next = True
            _get_next = lambda: self.get_many(
                ordering=ordering,
                ids=ids,
                title=title,
                page=page + 1 if page is not None else 1,
                page_size=page_size,
                request_options=request_options,
            )
            _items = _parsed_response.results
            return SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(self, *, request: Project, request_options: typing.Optional[RequestOptions] = None) -> Project:
        """
        Create a project and set up the labeling interface in Label Studio using the API.

        ```bash
        curl -H Content-Type:application/json -H 'Authorization: Token abc123' -X POST 'https://localhost:8080/api/projects'     --data '{"label_config": "<View>[...]</View>"}'
        ```

        Parameters
        ----------
        request : Project

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Project


        Examples
        --------
        from label_studio_sdk import Project
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.create(
            request=Project(),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/projects/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Project, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_validate_create(
        self, *, request: ProjectLabelConfig, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Validate an arbitrary labeling configuration.

        Parameters
        ----------
        request : ProjectLabelConfig

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk import ProjectLabelConfig
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.api_projects_validate_create(
            request=ProjectLabelConfig(
                label_config="label_config",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/projects/validate/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, id: int, *, request_options: typing.Optional[RequestOptions] = None) -> Project:
        """
        Retrieve information about a project by project ID.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Project
            Project information

        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.get(
            id=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Project, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, id: int, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a project by specified project ID.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.delete(
            id=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(self, id: int, *, request: Project, request_options: typing.Optional[RequestOptions] = None) -> Project:
        """
        Update the project settings for a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request : Project

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Project


        Examples
        --------
        from label_studio_sdk import Project
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.update(
            id=1,
            request=Project(),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="PATCH",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Project, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def import_tasks(
        self,
        id: int,
        *,
        data: typing.Dict[str, typing.Any],
        import_api_id: typing.Optional[int] = OMIT,
        annotations: typing.Optional[typing.Sequence[Annotation]] = OMIT,
        predictions: typing.Optional[typing.Sequence[Prediction]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProjectsImportTasksResponse:
        """
        Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
        One POST request is limited at 250K tasks and 200 MB.
        
        **Note:** Imported data is verified against a project _label_config_ and must
        include all variables that were used in the _label_config_. For example,
        if the label configuration has a _$text_ variable, then each item in a data object
        must include a "text" field.
        <br>
        
        ## POST requests
        
        <hr style="opacity:0.3">
        
        There are three possible ways to import tasks with this endpoint:
        
        ### 1\. **POST with data**
        
        Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
        Update this example to specify your authorization token and Label Studio instance host, then run the following from
        the command line.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
        ```
        
        ### 2\. **POST with files**
        
        Send tasks as files. You can attach multiple files with different names.
        
        - **JSON**: text files in JavaScript object notation format
        - **CSV**: text files with tables in Comma Separated Values format
        - **TSV**: text files with tables in Tab Separated Value format
        - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
        Update this example to specify your authorization token, Label Studio instance host, and file name and path,
        then run the following from the command line:
        
        ```bash
        curl -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' -F ‘file=@path/to/my_file.csv’
        ```
        
        ### 3\. **POST with URL**
        
        You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' \
        --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
        ```
        
        <br>
        
        Parameters
        ----------
        id : int
            A unique integer value identifying this project.
        
        data : typing.Dict[str, typing.Any]
            User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.
        
        import_api_id : typing.Optional[int]
        
        annotations : typing.Optional[typing.Sequence[Annotation]]
        
        predictions : typing.Optional[typing.Sequence[Prediction]]
        
        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.
        
        created_at : typing.Optional[dt.datetime]
            Time a task was created
        
        updated_at : typing.Optional[dt.datetime]
            Last time a task was updated
        
        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task
        
        inner_id : typing.Optional[int]
            Internal task ID in the project, starts with 1
        
        total_annotations : typing.Optional[int]
            Number of total annotations for the current task except cancelled annotations
        
        cancelled_annotations : typing.Optional[int]
            Number of total cancelled annotations for the current task
        
        total_predictions : typing.Optional[int]
            Number of total predictions for the current task
        
        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations
        
        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations
        
        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated
        
        updated_by : typing.Optional[int]
            Last annotator or reviewer who updated this task
        
        file_upload : typing.Optional[int]
            Uploaded file used as data source for this task
        
        comment_authors : typing.Optional[typing.Sequence[int]]
            Users who wrote comments
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        ProjectsImportTasksResponse
            Tasks successfully imported
        
        Examples
        --------
        from label_studio_sdk.client import LabelStudio
        
        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.import_tasks(
            id=1,
            data={},
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if import_api_id is not OMIT:
            _request["id"] = import_api_id
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if predictions is not OMIT:
            _request["predictions"] = predictions
        if meta is not OMIT:
            _request["meta"] = meta
        if created_at is not OMIT:
            _request["created_at"] = created_at
        if updated_at is not OMIT:
            _request["updated_at"] = updated_at
        if overlap is not OMIT:
            _request["overlap"] = overlap
        if inner_id is not OMIT:
            _request["inner_id"] = inner_id
        if total_annotations is not OMIT:
            _request["total_annotations"] = total_annotations
        if cancelled_annotations is not OMIT:
            _request["cancelled_annotations"] = cancelled_annotations
        if total_predictions is not OMIT:
            _request["total_predictions"] = total_predictions
        if comment_count is not OMIT:
            _request["comment_count"] = comment_count
        if unresolved_comment_count is not OMIT:
            _request["unresolved_comment_count"] = unresolved_comment_count
        if last_comment_updated_at is not OMIT:
            _request["last_comment_updated_at"] = last_comment_updated_at
        if updated_by is not OMIT:
            _request["updated_by"] = updated_by
        if file_upload is not OMIT:
            _request["file_upload"] = file_upload
        if comment_authors is not OMIT:
            _request["comment_authors"] = comment_authors
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/import"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectsImportTasksResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_imports_read(
        self, id: int, import_pk: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectImport:
        """
        Return data related to async project import operation

        Parameters
        ----------
        id : int
            A unique integer value identifying this project import.

        import_pk : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectImport


        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.api_projects_imports_read(
            id=1,
            import_pk="import_pk",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/projects/{jsonable_encoder(id)}/imports/{jsonable_encoder(import_pk)}/",
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectImport, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_reimports_read(
        self, id: int, reimport_pk: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectReimport:
        """
        Return data related to async project reimport operation

        Parameters
        ----------
        id : int
            A unique integer value identifying this project reimport.

        reimport_pk : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectReimport


        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.api_projects_reimports_read(
            id=1,
            reimport_pk="reimport_pk",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/projects/{jsonable_encoder(id)}/reimports/{jsonable_encoder(reimport_pk)}/",
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectReimport, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_tasks_list(
        self,
        id: int,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Retrieve a paginated list of tasks for a specific project. For example, use the following cURL command:

        ```bash
        curl -X GET https://localhost:8080/api/projects/{id}/tasks/?page=1&page_size=10 -H 'Authorization: Token abc123'
        ```

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        page : typing.Optional[int]
            [or "start"] current page

        page_size : typing.Optional[int]
            [or "length"] tasks per page, use -1 to obtain all tasks (in this case "page" has no effect and this operation might be slow)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.api_projects_tasks_list(
            id=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/tasks/"
            ),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        {
                            "page": page,
                            "page_size": page_size,
                            **(
                                request_options.get("additional_query_parameters", {})
                                if request_options is not None
                                else {}
                            ),
                        }
                    )
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_tasks_delete(self, id: int, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete all tasks from a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.api_projects_tasks_delete(
            id=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/tasks/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_validate_label_config(
        self, id: int, *, request: ProjectLabelConfig, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectLabelConfig:
        """
        Determine whether the label configuration for a specific project is valid.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request : ProjectLabelConfig

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectLabelConfig


        Examples
        --------
        from label_studio_sdk import ProjectLabelConfig
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.projects.api_projects_validate_label_config(
            id=1,
            request=ProjectLabelConfig(
                label_config="label_config",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/validate/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectLabelConfig, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProjectsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_many(
        self,
        *,
        ordering: typing.Optional[str] = None,
        ids: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[Project]:
        """
        Return a list of the projects that you've created.

        To perform most tasks with the Label Studio API, you must specify the project ID, sometimes referred to as the `pk`.
        To retrieve a list of your Label Studio projects, update the following command to match your own environment.
        Replace the domain name, port, and authorization token, then run the following from the command line:

        ```bash
        curl -X GET https://localhost:8080/api/projects/ -H 'Authorization: Token abc123'
        ```

        Parameters
        ----------
        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        ids : typing.Optional[str]
            ids

        title : typing.Optional[str]
            title

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[Project]


        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.get_many()
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/projects/"),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        {
                            "ordering": ordering,
                            "ids": ids,
                            "title": title,
                            "page": page,
                            "page_size": page_size,
                            **(
                                request_options.get("additional_query_parameters", {})
                                if request_options is not None
                                else {}
                            ),
                        }
                    )
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic_v1.parse_obj_as(ProjectsGetManyResponse, _response.json())  # type: ignore
            _has_next = True
            _get_next = lambda: self.get_many(
                ordering=ordering,
                ids=ids,
                title=title,
                page=page + 1 if page is not None else 1,
                page_size=page_size,
                request_options=request_options,
            )
            _items = _parsed_response.results
            return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(self, *, request: Project, request_options: typing.Optional[RequestOptions] = None) -> Project:
        """
        Create a project and set up the labeling interface in Label Studio using the API.

        ```bash
        curl -H Content-Type:application/json -H 'Authorization: Token abc123' -X POST 'https://localhost:8080/api/projects'     --data '{"label_config": "<View>[...]</View>"}'
        ```

        Parameters
        ----------
        request : Project

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Project


        Examples
        --------
        from label_studio_sdk import Project
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.create(
            request=Project(),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/projects/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Project, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_validate_create(
        self, *, request: ProjectLabelConfig, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Validate an arbitrary labeling configuration.

        Parameters
        ----------
        request : ProjectLabelConfig

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk import ProjectLabelConfig
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.api_projects_validate_create(
            request=ProjectLabelConfig(
                label_config="label_config",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/projects/validate/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, id: int, *, request_options: typing.Optional[RequestOptions] = None) -> Project:
        """
        Retrieve information about a project by project ID.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Project
            Project information

        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.get(
            id=1,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Project, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, id: int, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a project by specified project ID.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.delete(
            id=1,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self, id: int, *, request: Project, request_options: typing.Optional[RequestOptions] = None
    ) -> Project:
        """
        Update the project settings for a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request : Project

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Project


        Examples
        --------
        from label_studio_sdk import Project
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.update(
            id=1,
            request=Project(),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="PATCH",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Project, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def import_tasks(
        self,
        id: int,
        *,
        data: typing.Dict[str, typing.Any],
        import_api_id: typing.Optional[int] = OMIT,
        annotations: typing.Optional[typing.Sequence[Annotation]] = OMIT,
        predictions: typing.Optional[typing.Sequence[Prediction]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProjectsImportTasksResponse:
        """
        Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
        One POST request is limited at 250K tasks and 200 MB.
        
        **Note:** Imported data is verified against a project _label_config_ and must
        include all variables that were used in the _label_config_. For example,
        if the label configuration has a _$text_ variable, then each item in a data object
        must include a "text" field.
        <br>
        
        ## POST requests
        
        <hr style="opacity:0.3">
        
        There are three possible ways to import tasks with this endpoint:
        
        ### 1\. **POST with data**
        
        Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
        Update this example to specify your authorization token and Label Studio instance host, then run the following from
        the command line.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
        ```
        
        ### 2\. **POST with files**
        
        Send tasks as files. You can attach multiple files with different names.
        
        - **JSON**: text files in JavaScript object notation format
        - **CSV**: text files with tables in Comma Separated Values format
        - **TSV**: text files with tables in Tab Separated Value format
        - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
        Update this example to specify your authorization token, Label Studio instance host, and file name and path,
        then run the following from the command line:
        
        ```bash
        curl -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' -F ‘file=@path/to/my_file.csv’
        ```
        
        ### 3\. **POST with URL**
        
        You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' \
        --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
        ```
        
        <br>
        
        Parameters
        ----------
        id : int
            A unique integer value identifying this project.
        
        data : typing.Dict[str, typing.Any]
            User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.
        
        import_api_id : typing.Optional[int]
        
        annotations : typing.Optional[typing.Sequence[Annotation]]
        
        predictions : typing.Optional[typing.Sequence[Prediction]]
        
        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.
        
        created_at : typing.Optional[dt.datetime]
            Time a task was created
        
        updated_at : typing.Optional[dt.datetime]
            Last time a task was updated
        
        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task
        
        inner_id : typing.Optional[int]
            Internal task ID in the project, starts with 1
        
        total_annotations : typing.Optional[int]
            Number of total annotations for the current task except cancelled annotations
        
        cancelled_annotations : typing.Optional[int]
            Number of total cancelled annotations for the current task
        
        total_predictions : typing.Optional[int]
            Number of total predictions for the current task
        
        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations
        
        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations
        
        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated
        
        updated_by : typing.Optional[int]
            Last annotator or reviewer who updated this task
        
        file_upload : typing.Optional[int]
            Uploaded file used as data source for this task
        
        comment_authors : typing.Optional[typing.Sequence[int]]
            Users who wrote comments
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        ProjectsImportTasksResponse
            Tasks successfully imported
        
        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio
        
        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.import_tasks(
            id=1,
            data={},
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if import_api_id is not OMIT:
            _request["id"] = import_api_id
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if predictions is not OMIT:
            _request["predictions"] = predictions
        if meta is not OMIT:
            _request["meta"] = meta
        if created_at is not OMIT:
            _request["created_at"] = created_at
        if updated_at is not OMIT:
            _request["updated_at"] = updated_at
        if overlap is not OMIT:
            _request["overlap"] = overlap
        if inner_id is not OMIT:
            _request["inner_id"] = inner_id
        if total_annotations is not OMIT:
            _request["total_annotations"] = total_annotations
        if cancelled_annotations is not OMIT:
            _request["cancelled_annotations"] = cancelled_annotations
        if total_predictions is not OMIT:
            _request["total_predictions"] = total_predictions
        if comment_count is not OMIT:
            _request["comment_count"] = comment_count
        if unresolved_comment_count is not OMIT:
            _request["unresolved_comment_count"] = unresolved_comment_count
        if last_comment_updated_at is not OMIT:
            _request["last_comment_updated_at"] = last_comment_updated_at
        if updated_by is not OMIT:
            _request["updated_by"] = updated_by
        if file_upload is not OMIT:
            _request["file_upload"] = file_upload
        if comment_authors is not OMIT:
            _request["comment_authors"] = comment_authors
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/import"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectsImportTasksResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_imports_read(
        self, id: int, import_pk: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectImport:
        """
        Return data related to async project import operation

        Parameters
        ----------
        id : int
            A unique integer value identifying this project import.

        import_pk : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectImport


        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.api_projects_imports_read(
            id=1,
            import_pk="import_pk",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/projects/{jsonable_encoder(id)}/imports/{jsonable_encoder(import_pk)}/",
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectImport, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_reimports_read(
        self, id: int, reimport_pk: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectReimport:
        """
        Return data related to async project reimport operation

        Parameters
        ----------
        id : int
            A unique integer value identifying this project reimport.

        reimport_pk : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectReimport


        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.api_projects_reimports_read(
            id=1,
            reimport_pk="reimport_pk",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/projects/{jsonable_encoder(id)}/reimports/{jsonable_encoder(reimport_pk)}/",
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectReimport, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_tasks_list(
        self,
        id: int,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Retrieve a paginated list of tasks for a specific project. For example, use the following cURL command:

        ```bash
        curl -X GET https://localhost:8080/api/projects/{id}/tasks/?page=1&page_size=10 -H 'Authorization: Token abc123'
        ```

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        page : typing.Optional[int]
            [or "start"] current page

        page_size : typing.Optional[int]
            [or "length"] tasks per page, use -1 to obtain all tasks (in this case "page" has no effect and this operation might be slow)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.api_projects_tasks_list(
            id=1,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/tasks/"
            ),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        {
                            "page": page,
                            "page_size": page_size,
                            **(
                                request_options.get("additional_query_parameters", {})
                                if request_options is not None
                                else {}
                            ),
                        }
                    )
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_tasks_delete(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete all tasks from a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.api_projects_tasks_delete(
            id=1,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/tasks/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_validate_label_config(
        self, id: int, *, request: ProjectLabelConfig, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectLabelConfig:
        """
        Determine whether the label configuration for a specific project is valid.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request : ProjectLabelConfig

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectLabelConfig


        Examples
        --------
        from label_studio_sdk import ProjectLabelConfig
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.projects.api_projects_validate_label_config(
            id=1,
            request=ProjectLabelConfig(
                label_config="label_config",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/validate/"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectLabelConfig, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
