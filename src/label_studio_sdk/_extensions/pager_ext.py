import typing

from label_studio_sdk.core.api_error import ApiError
from label_studio_sdk.core.pagination import AsyncPager, SyncPager, T, R

# This is a custom extension of the autogenerated SyncPager and AsyncPager classes
# that works with the Label Studio SDK's default pagination behavior
# that throws 404 errors at the end of the pagination.


class SyncPagerExt(typing.Generic[T, R]):
    """
    Wrapper around Fern's generated SyncPager.

    Newer Fern SDKs model the pager as a frozen dataclass with a required `response` field.
    That makes subclassing/reconstructing it brittle. Instead we wrap it and only customize
    iteration behavior to treat 404-at-end as pagination completion.
    """

    def __init__(self, pager: SyncPager[T, R]):
        self._pager = pager

    @classmethod
    def from_sync_pager(cls, sync_pager: SyncPager[T, R]) -> "SyncPagerExt[T, R]":
        return cls(sync_pager)

    @property
    def response(self) -> R:
        return self._pager.response

    @property
    def items(self) -> typing.Optional[typing.List[T]]:
        return self._pager.items

    @property
    def has_next(self) -> bool:
        return self._pager.has_next

    def next_page(self) -> typing.Optional["SyncPagerExt[T, R]"]:
        if self._pager.get_next is None:
            return None
        try:
            nxt = self._pager.get_next()
        except ApiError as exc:
            if exc.status_code == 404:
                return None
            raise
        return SyncPagerExt.from_sync_pager(nxt) if nxt is not None else None

    def iter_pages(self) -> typing.Iterator["SyncPagerExt[T, R]"]:
        page: typing.Optional[SyncPager[T, R]] = self._pager
        while page is not None:
            yield SyncPagerExt.from_sync_pager(page)

            if not page.has_next or page.get_next is None:
                return

            try:
                page = page.get_next()
            except ApiError as exc:
                if exc.status_code == 404:
                    return
                raise

            if page is None or page.items is None or len(page.items) == 0:
                return

    def __iter__(self) -> typing.Iterator[T]:  # type: ignore
        for page in self.iter_pages():
            if page.items is not None:
                yield from page.items


class AsyncPagerExt(typing.Generic[T, R]):
    """
    Async wrapper around Fern's generated AsyncPager. See SyncPagerExt for rationale.
    """

    def __init__(self, pager: AsyncPager[T, R]):
        self._pager = pager

    @classmethod
    async def from_async_pager(cls, async_pager: AsyncPager[T, R]) -> "AsyncPagerExt[T, R]":
        return cls(async_pager)

    @property
    def response(self) -> R:
        return self._pager.response

    @property
    def items(self) -> typing.Optional[typing.List[T]]:
        return self._pager.items

    @property
    def has_next(self) -> bool:
        return self._pager.has_next

    async def next_page(self) -> typing.Optional["AsyncPagerExt[T, R]"]:
        if self._pager.get_next is None:
            return None
        try:
            nxt = await self._pager.get_next()
        except ApiError as exc:
            if exc.status_code == 404:
                return None
            raise
        return await AsyncPagerExt.from_async_pager(nxt) if nxt is not None else None

    async def iter_pages(self) -> typing.AsyncIterator["AsyncPagerExt[T, R]"]:
        page: typing.Optional[AsyncPager[T, R]] = self._pager
        while page is not None:
            yield await AsyncPagerExt.from_async_pager(page)

            if not page.has_next or page.get_next is None:
                return

            try:
                page = await page.get_next()
            except ApiError as exc:
                if exc.status_code == 404:
                    return
                raise

            if page is None or page.items is None or len(page.items) == 0:
                return

    async def __aiter__(self) -> typing.AsyncIterator[T]:  # type: ignore
        async for page in self.iter_pages():
            if page.items is not None:
                for item in page.items:
                    yield item
