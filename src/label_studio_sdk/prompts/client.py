# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .indicators.client import IndicatorsClient
from .versions.client import VersionsClient
from .runs.client import RunsClient
from ..core.request_options import RequestOptions
from ..types.batch_failed_predictions import BatchFailedPredictions
from ..core.unchecked_base_model import construct_type
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.batch_predictions import BatchPredictions
from ..types.model_interface_serializer_get import ModelInterfaceSerializerGet
from ..types.user_simple_request import UserSimpleRequest
from ..types.skill_name_enum import SkillNameEnum
from ..types.model_interface import ModelInterface
from ..core.serialization import convert_and_respect_annotation_metadata
from .types.prompts_compatible_projects_request_project_type import PromptsCompatibleProjectsRequestProjectType
from ..types.paginated_all_roles_project_list_list import PaginatedAllRolesProjectListList
from ..core.jsonable_encoder import jsonable_encoder
from ..core.client_wrapper import AsyncClientWrapper
from .indicators.client import AsyncIndicatorsClient
from .versions.client import AsyncVersionsClient
from .runs.client import AsyncRunsClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class PromptsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.indicators = IndicatorsClient(client_wrapper=self._client_wrapper)
        self.versions = VersionsClient(client_wrapper=self._client_wrapper)
        self.runs = RunsClient(client_wrapper=self._client_wrapper)

    def batch_failed_predictions(
        self,
        *,
        failed_predictions: typing.Sequence[typing.Optional[typing.Any]],
        modelrun_id: int,
        num_failed_predictions: typing.Optional[int] = None,
        job_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchFailedPredictions:
        """
        Create a new batch of failed predictions.

        Parameters
        ----------
        failed_predictions : typing.Sequence[typing.Optional[typing.Any]]

        modelrun_id : int

        num_failed_predictions : typing.Optional[int]
            Number of failed predictions being sent (for telemetry only, has no effect)

        job_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchFailedPredictions


        Examples
        --------
        from label_studio_sdk import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.prompts.batch_failed_predictions(
            failed_predictions=[],
            modelrun_id=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/model-run/batch-failed-predictions",
            method="POST",
            params={
                "num_failed_predictions": num_failed_predictions,
            },
            json={
                "failed_predictions": failed_predictions,
                "job_id": job_id,
                "modelrun_id": modelrun_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchFailedPredictions,
                    construct_type(
                        type_=BatchFailedPredictions,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def batch_predictions(
        self,
        *,
        modelrun_id: int,
        results: typing.Sequence[typing.Optional[typing.Any]],
        num_predictions: typing.Optional[int] = None,
        job_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchPredictions:
        """
        Create a new batch prediction.

        Parameters
        ----------
        modelrun_id : int

        results : typing.Sequence[typing.Optional[typing.Any]]

        num_predictions : typing.Optional[int]
            Number of predictions being sent (for telemetry only, has no effect)

        job_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchPredictions


        Examples
        --------
        from label_studio_sdk import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.prompts.batch_predictions(
            modelrun_id=1,
            results=[],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/model-run/batch-predictions",
            method="POST",
            params={
                "num_predictions": num_predictions,
            },
            json={
                "job_id": job_id,
                "modelrun_id": modelrun_id,
                "results": results,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchPredictions,
                    construct_type(
                        type_=BatchPredictions,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list(
        self, *, ordering: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[ModelInterfaceSerializerGet]:
        """
        List all prompts.

        Parameters
        ----------
        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ModelInterfaceSerializerGet]


        Examples
        --------
        from label_studio_sdk import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.prompts.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/prompts/",
            method="GET",
            params={
                "ordering": ordering,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ModelInterfaceSerializerGet],
                    construct_type(
                        type_=typing.List[ModelInterfaceSerializerGet],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        title: str,
        associated_projects: typing.Optional[typing.Sequence[int]] = OMIT,
        created_by: typing.Optional[UserSimpleRequest] = OMIT,
        description: typing.Optional[str] = OMIT,
        input_fields: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        organization: typing.Optional[int] = OMIT,
        output_classes: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        skill_name: typing.Optional[SkillNameEnum] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelInterface:
        """
        Create a new prompt.

        Parameters
        ----------
        title : str
            Model name

        associated_projects : typing.Optional[typing.Sequence[int]]

        created_by : typing.Optional[UserSimpleRequest]
            User who created Dataset

        description : typing.Optional[str]
            Model description

        input_fields : typing.Optional[typing.Optional[typing.Any]]

        organization : typing.Optional[int]

        output_classes : typing.Optional[typing.Optional[typing.Any]]

        skill_name : typing.Optional[SkillNameEnum]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelInterface


        Examples
        --------
        from label_studio_sdk import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.prompts.create(
            title="title",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/prompts/",
            method="POST",
            json={
                "associated_projects": associated_projects,
                "created_by": convert_and_respect_annotation_metadata(
                    object_=created_by, annotation=UserSimpleRequest, direction="write"
                ),
                "description": description,
                "input_fields": input_fields,
                "organization": organization,
                "output_classes": output_classes,
                "skill_name": skill_name,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelInterface,
                    construct_type(
                        type_=ModelInterface,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def compatible_projects(
        self,
        *,
        ordering: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        project_type: typing.Optional[PromptsCompatibleProjectsRequestProjectType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PaginatedAllRolesProjectListList:
        """
        Retrieve a list of compatible project for prompt.

        Parameters
        ----------
        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        project_type : typing.Optional[PromptsCompatibleProjectsRequestProjectType]
            Skill to filter by

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaginatedAllRolesProjectListList


        Examples
        --------
        from label_studio_sdk import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.prompts.compatible_projects()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/prompts/compatible-projects",
            method="GET",
            params={
                "ordering": ordering,
                "page": page,
                "page_size": page_size,
                "project_type": project_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PaginatedAllRolesProjectListList,
                    construct_type(
                        type_=PaginatedAllRolesProjectListList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> ModelInterfaceSerializerGet:
        """
        Retrieve a specific prompt.

        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelInterfaceSerializerGet


        Examples
        --------
        from label_studio_sdk import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.prompts.get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/prompts/{jsonable_encoder(id)}/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelInterfaceSerializerGet,
                    construct_type(
                        type_=ModelInterfaceSerializerGet,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a prompt by ID

        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.prompts.delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/prompts/{jsonable_encoder(id)}/",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        id: str,
        *,
        associated_projects: typing.Optional[typing.Sequence[int]] = OMIT,
        created_by: typing.Optional[UserSimpleRequest] = OMIT,
        description: typing.Optional[str] = OMIT,
        input_fields: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        organization: typing.Optional[int] = OMIT,
        output_classes: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        skill_name: typing.Optional[SkillNameEnum] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelInterface:
        """
        Update a specific prompt by ID.

        Parameters
        ----------
        id : str

        associated_projects : typing.Optional[typing.Sequence[int]]

        created_by : typing.Optional[UserSimpleRequest]
            User who created Dataset

        description : typing.Optional[str]
            Model description

        input_fields : typing.Optional[typing.Optional[typing.Any]]

        organization : typing.Optional[int]

        output_classes : typing.Optional[typing.Optional[typing.Any]]

        skill_name : typing.Optional[SkillNameEnum]

        title : typing.Optional[str]
            Model name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelInterface


        Examples
        --------
        from label_studio_sdk import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.prompts.update(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/prompts/{jsonable_encoder(id)}/",
            method="PATCH",
            json={
                "associated_projects": associated_projects,
                "created_by": convert_and_respect_annotation_metadata(
                    object_=created_by, annotation=UserSimpleRequest, direction="write"
                ),
                "description": description,
                "input_fields": input_fields,
                "organization": organization,
                "output_classes": output_classes,
                "skill_name": skill_name,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelInterface,
                    construct_type(
                        type_=ModelInterface,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncPromptsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.indicators = AsyncIndicatorsClient(client_wrapper=self._client_wrapper)
        self.versions = AsyncVersionsClient(client_wrapper=self._client_wrapper)
        self.runs = AsyncRunsClient(client_wrapper=self._client_wrapper)

    async def batch_failed_predictions(
        self,
        *,
        failed_predictions: typing.Sequence[typing.Optional[typing.Any]],
        modelrun_id: int,
        num_failed_predictions: typing.Optional[int] = None,
        job_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchFailedPredictions:
        """
        Create a new batch of failed predictions.

        Parameters
        ----------
        failed_predictions : typing.Sequence[typing.Optional[typing.Any]]

        modelrun_id : int

        num_failed_predictions : typing.Optional[int]
            Number of failed predictions being sent (for telemetry only, has no effect)

        job_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchFailedPredictions


        Examples
        --------
        import asyncio

        from label_studio_sdk import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.prompts.batch_failed_predictions(
                failed_predictions=[],
                modelrun_id=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/model-run/batch-failed-predictions",
            method="POST",
            params={
                "num_failed_predictions": num_failed_predictions,
            },
            json={
                "failed_predictions": failed_predictions,
                "job_id": job_id,
                "modelrun_id": modelrun_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchFailedPredictions,
                    construct_type(
                        type_=BatchFailedPredictions,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def batch_predictions(
        self,
        *,
        modelrun_id: int,
        results: typing.Sequence[typing.Optional[typing.Any]],
        num_predictions: typing.Optional[int] = None,
        job_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchPredictions:
        """
        Create a new batch prediction.

        Parameters
        ----------
        modelrun_id : int

        results : typing.Sequence[typing.Optional[typing.Any]]

        num_predictions : typing.Optional[int]
            Number of predictions being sent (for telemetry only, has no effect)

        job_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchPredictions


        Examples
        --------
        import asyncio

        from label_studio_sdk import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.prompts.batch_predictions(
                modelrun_id=1,
                results=[],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/model-run/batch-predictions",
            method="POST",
            params={
                "num_predictions": num_predictions,
            },
            json={
                "job_id": job_id,
                "modelrun_id": modelrun_id,
                "results": results,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchPredictions,
                    construct_type(
                        type_=BatchPredictions,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list(
        self, *, ordering: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[ModelInterfaceSerializerGet]:
        """
        List all prompts.

        Parameters
        ----------
        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[ModelInterfaceSerializerGet]


        Examples
        --------
        import asyncio

        from label_studio_sdk import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.prompts.list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/prompts/",
            method="GET",
            params={
                "ordering": ordering,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[ModelInterfaceSerializerGet],
                    construct_type(
                        type_=typing.List[ModelInterfaceSerializerGet],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        title: str,
        associated_projects: typing.Optional[typing.Sequence[int]] = OMIT,
        created_by: typing.Optional[UserSimpleRequest] = OMIT,
        description: typing.Optional[str] = OMIT,
        input_fields: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        organization: typing.Optional[int] = OMIT,
        output_classes: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        skill_name: typing.Optional[SkillNameEnum] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelInterface:
        """
        Create a new prompt.

        Parameters
        ----------
        title : str
            Model name

        associated_projects : typing.Optional[typing.Sequence[int]]

        created_by : typing.Optional[UserSimpleRequest]
            User who created Dataset

        description : typing.Optional[str]
            Model description

        input_fields : typing.Optional[typing.Optional[typing.Any]]

        organization : typing.Optional[int]

        output_classes : typing.Optional[typing.Optional[typing.Any]]

        skill_name : typing.Optional[SkillNameEnum]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelInterface


        Examples
        --------
        import asyncio

        from label_studio_sdk import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.prompts.create(
                title="title",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/prompts/",
            method="POST",
            json={
                "associated_projects": associated_projects,
                "created_by": convert_and_respect_annotation_metadata(
                    object_=created_by, annotation=UserSimpleRequest, direction="write"
                ),
                "description": description,
                "input_fields": input_fields,
                "organization": organization,
                "output_classes": output_classes,
                "skill_name": skill_name,
                "title": title,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelInterface,
                    construct_type(
                        type_=ModelInterface,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def compatible_projects(
        self,
        *,
        ordering: typing.Optional[str] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        project_type: typing.Optional[PromptsCompatibleProjectsRequestProjectType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PaginatedAllRolesProjectListList:
        """
        Retrieve a list of compatible project for prompt.

        Parameters
        ----------
        ordering : typing.Optional[str]
            Which field to use when ordering the results.

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        project_type : typing.Optional[PromptsCompatibleProjectsRequestProjectType]
            Skill to filter by

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaginatedAllRolesProjectListList


        Examples
        --------
        import asyncio

        from label_studio_sdk import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.prompts.compatible_projects()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/prompts/compatible-projects",
            method="GET",
            params={
                "ordering": ordering,
                "page": page,
                "page_size": page_size,
                "project_type": project_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PaginatedAllRolesProjectListList,
                    construct_type(
                        type_=PaginatedAllRolesProjectListList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ModelInterfaceSerializerGet:
        """
        Retrieve a specific prompt.

        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelInterfaceSerializerGet


        Examples
        --------
        import asyncio

        from label_studio_sdk import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.prompts.get(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/prompts/{jsonable_encoder(id)}/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelInterfaceSerializerGet,
                    construct_type(
                        type_=ModelInterfaceSerializerGet,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a prompt by ID

        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from label_studio_sdk import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.prompts.delete(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/prompts/{jsonable_encoder(id)}/",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        id: str,
        *,
        associated_projects: typing.Optional[typing.Sequence[int]] = OMIT,
        created_by: typing.Optional[UserSimpleRequest] = OMIT,
        description: typing.Optional[str] = OMIT,
        input_fields: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        organization: typing.Optional[int] = OMIT,
        output_classes: typing.Optional[typing.Optional[typing.Any]] = OMIT,
        skill_name: typing.Optional[SkillNameEnum] = OMIT,
        title: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelInterface:
        """
        Update a specific prompt by ID.

        Parameters
        ----------
        id : str

        associated_projects : typing.Optional[typing.Sequence[int]]

        created_by : typing.Optional[UserSimpleRequest]
            User who created Dataset

        description : typing.Optional[str]
            Model description

        input_fields : typing.Optional[typing.Optional[typing.Any]]

        organization : typing.Optional[int]

        output_classes : typing.Optional[typing.Optional[typing.Any]]

        skill_name : typing.Optional[SkillNameEnum]

        title : typing.Optional[str]
            Model name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelInterface


        Examples
        --------
        import asyncio

        from label_studio_sdk import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.prompts.update(
                id="id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/prompts/{jsonable_encoder(id)}/",
            method="PATCH",
            json={
                "associated_projects": associated_projects,
                "created_by": convert_and_respect_annotation_metadata(
                    object_=created_by, annotation=UserSimpleRequest, direction="write"
                ),
                "description": description,
                "input_fields": input_fields,
                "organization": organization,
                "output_classes": output_classes,
                "skill_name": skill_name,
                "title": title,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelInterface,
                    construct_type(
                        type_=ModelInterface,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
