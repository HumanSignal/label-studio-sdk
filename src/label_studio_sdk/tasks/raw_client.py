# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.lse_task import LseTask
from ..types.paginated_role_based_task_list import PaginatedRoleBasedTaskList
from ..types.project_import import ProjectImport
from ..types.role_based_task import RoleBasedTask
from ..types.task_event import TaskEvent
from .types.list_tasks_request_fields import ListTasksRequestFields

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawTasksClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_many_status(
        self, id: int, import_pk: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ProjectImport]:
        """

                    Poll the status of an asynchronous project import operation.

                    **Usage:**
                    1. When you POST to `/api/projects/{project_id}/import`, you'll receive a response like `{"import": <import_id>}`
                    2. Use that `import_id` with this GET endpoint to check the import status
                    3. Poll this endpoint to see if the import has completed, is still processing, or has failed
                    4. **Import errors and failures will only be visible in this GET response**, not in the original POST request

                    This endpoint returns detailed information about the import including task counts, status, and any error messages.


        Parameters
        ----------
        id : int
            A unique integer value identifying this project import.

        import_pk : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ProjectImport]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/imports/{jsonable_encoder(import_pk)}/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProjectImport,
                    construct_type(
                        type_=ProjectImport,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_all_tasks(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete all tasks from a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/tasks/",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list(
        self,
        *,
        fields: typing.Optional[ListTasksRequestFields] = None,
        include: typing.Optional[str] = None,
        only_annotated: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        project: typing.Optional[int] = None,
        query: typing.Optional[str] = None,
        resolve_uri: typing.Optional[bool] = None,
        review: typing.Optional[bool] = None,
        selected_items: typing.Optional[str] = None,
        view: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[RoleBasedTask, PaginatedRoleBasedTaskList]:
        """
        Retrieve a paginated list of tasks. The response format varies based on the user's role in the organization:
        - **Admin/Owner**: Full task details with all annotations, reviews, and metadata
        - **Reviewer**: Task details optimized for review workflow
        - **Annotator**: Task details filtered to show only user's own annotations and assignments

        Parameters
        ----------
        fields : typing.Optional[ListTasksRequestFields]
            Set to "all" if you want to include annotations and predictions in the response. Defaults to task_only

        include : typing.Optional[str]
            Specify which fields to include in the response

        only_annotated : typing.Optional[bool]
            Filter to show only tasks that have annotations

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        project : typing.Optional[int]
            Project ID

        query : typing.Optional[str]
            Additional query to filter tasks. It must be JSON encoded string of dict containing one of the following parameters: {"filters": ..., "selectedItems": ..., "ordering": ...}. Check Data Manager > Create View > see data field for more details about filters, selectedItems and ordering.

            filters: dict with "conjunction" string ("or" or "and") and list of filters in "items" array. Each filter is a dictionary with keys: "filter", "operator", "type", "value". Read more about available filters
            Example: {"conjunction": "or", "items": [{"filter": "filter:tasks:completed_at", "operator": "greater", "type": "Datetime", "value": "2021-01-01T00:00:00.000Z"}]}
            selectedItems: dictionary with keys: "all", "included", "excluded". If "all" is false, "included" must be used. If "all" is true, "excluded" must be used.
            Examples: {"all": false, "included": [1, 2, 3]} or {"all": true, "excluded": [4, 5]}
            ordering: list of fields to order by. Currently, ordering is supported by only one parameter.
            Example: ["completed_at"]

        resolve_uri : typing.Optional[bool]
            Resolve task data URIs using Cloud Storage

        review : typing.Optional[bool]
            Get tasks for review

        selected_items : typing.Optional[str]
            JSON string of selected task IDs for review workflow

        view : typing.Optional[int]
            View ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[RoleBasedTask, PaginatedRoleBasedTaskList]

        """
        page = page if page is not None else 1

        _response = self._client_wrapper.httpx_client.request(
            "api/tasks/",
            method="GET",
            params={
                "fields": fields,
                "include": include,
                "only_annotated": only_annotated,
                "page": page,
                "page_size": page_size,
                "project": project,
                "query": query,
                "resolve_uri": resolve_uri,
                "review": review,
                "selectedItems": selected_items,
                "view": view,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedRoleBasedTaskList,
                    construct_type(
                        type_=PaginatedRoleBasedTaskList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.tasks
                _has_next = True
                _get_next = lambda: self.list(
                    fields=fields,
                    include=include,
                    only_annotated=only_annotated,
                    page=page + 1,
                    page_size=page_size,
                    project=project,
                    query=query,
                    resolve_uri=resolve_uri,
                    review=review,
                    selected_items=selected_items,
                    view=view,
                    request_options=request_options,
                )
                return SyncPager(has_next=_has_next, items=_items, get_next=_get_next, response=_parsed_response)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        data: typing.Any,
        allow_skip: typing.Optional[bool] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.Sequence[int]] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        is_labeled: typing.Optional[bool] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        meta: typing.Optional[typing.Any] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        project: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[LseTask]:
        """
        Create a new task

        Parameters
        ----------
        data : typing.Any

        allow_skip : typing.Optional[bool]
            Whether this task can be skipped. Set to False to make task unskippable.

        cancelled_annotations : typing.Optional[int]
            Number of total cancelled annotations for the current task

        comment_authors : typing.Optional[typing.Sequence[int]]
            Users who wrote comments

        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations

        file_upload : typing.Optional[int]
            Uploaded file used as data source for this task

        inner_id : typing.Optional[int]
            Internal task ID in the project, starts with 1

        is_labeled : typing.Optional[bool]
            True if the number of annotations for this task is greater than or equal to the number of maximum_completions for the project

        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated

        meta : typing.Optional[typing.Any]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.

        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task

        project : typing.Optional[int]
            Project ID for this task

        total_annotations : typing.Optional[int]
            Number of total annotations for the current task except cancelled annotations

        total_predictions : typing.Optional[int]
            Number of total predictions for the current task

        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations

        updated_by : typing.Optional[int]
            Last annotator or reviewer who updated this task

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[LseTask]

        """
        _response = self._client_wrapper.httpx_client.request(
            "api/tasks/",
            method="POST",
            json={
                "allow_skip": allow_skip,
                "cancelled_annotations": cancelled_annotations,
                "comment_authors": comment_authors,
                "comment_count": comment_count,
                "data": data,
                "file_upload": file_upload,
                "inner_id": inner_id,
                "is_labeled": is_labeled,
                "last_comment_updated_at": last_comment_updated_at,
                "meta": meta,
                "overlap": overlap,
                "project": project,
                "total_annotations": total_annotations,
                "total_predictions": total_predictions,
                "unresolved_comment_count": unresolved_comment_count,
                "updated_by": updated_by,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LseTask,
                    construct_type(
                        type_=LseTask,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[RoleBasedTask]:
        """
        Get task data, metadata, annotations and other attributes for a specific labeling task by task ID.

        Parameters
        ----------
        id : str
            Task ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RoleBasedTask]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/tasks/{jsonable_encoder(id)}/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RoleBasedTask,
                    construct_type(
                        type_=RoleBasedTask,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[None]:
        """
        Delete a task in Label Studio. This action cannot be undone!

        Parameters
        ----------
        id : str
            Task ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/tasks/{jsonable_encoder(id)}/",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        id: str,
        *,
        allow_skip: typing.Optional[bool] = OMIT,
        avg_lead_time: typing.Optional[float] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        completed_at: typing.Optional[dt.datetime] = OMIT,
        data: typing.Optional[typing.Any] = OMIT,
        draft_exists: typing.Optional[bool] = OMIT,
        ground_truth: typing.Optional[bool] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        is_labeled: typing.Optional[bool] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        meta: typing.Optional[typing.Any] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        precomputed_agreement: typing.Optional[float] = OMIT,
        predictions_score: typing.Optional[float] = OMIT,
        project: typing.Optional[int] = OMIT,
        reviewed: typing.Optional[bool] = OMIT,
        reviews_accepted: typing.Optional[int] = OMIT,
        reviews_rejected: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RoleBasedTask]:
        """
        Update the attributes of an existing labeling task.

        Parameters
        ----------
        id : str
            Task ID

        allow_skip : typing.Optional[bool]
            Whether this task can be skipped. Set to False to make task unskippable.

        avg_lead_time : typing.Optional[float]

        cancelled_annotations : typing.Optional[int]

        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations

        completed_at : typing.Optional[dt.datetime]

        data : typing.Optional[typing.Any]
            User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.

        draft_exists : typing.Optional[bool]

        ground_truth : typing.Optional[bool]

        inner_id : typing.Optional[int]

        is_labeled : typing.Optional[bool]
            True if the number of annotations for this task is greater than or equal to the number of maximum_completions for the project

        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated

        meta : typing.Optional[typing.Any]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.

        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task

        precomputed_agreement : typing.Optional[float]
            Average agreement score for the task

        predictions_score : typing.Optional[float]

        project : typing.Optional[int]
            Project ID for this task

        reviewed : typing.Optional[bool]

        reviews_accepted : typing.Optional[int]

        reviews_rejected : typing.Optional[int]

        total_annotations : typing.Optional[int]

        total_predictions : typing.Optional[int]

        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RoleBasedTask]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/tasks/{jsonable_encoder(id)}/",
            method="PATCH",
            json={
                "allow_skip": allow_skip,
                "avg_lead_time": avg_lead_time,
                "cancelled_annotations": cancelled_annotations,
                "comment_count": comment_count,
                "completed_at": completed_at,
                "data": data,
                "draft_exists": draft_exists,
                "ground_truth": ground_truth,
                "inner_id": inner_id,
                "is_labeled": is_labeled,
                "last_comment_updated_at": last_comment_updated_at,
                "meta": meta,
                "overlap": overlap,
                "precomputed_agreement": precomputed_agreement,
                "predictions_score": predictions_score,
                "project": project,
                "reviewed": reviewed,
                "reviews_accepted": reviews_accepted,
                "reviews_rejected": reviews_rejected,
                "total_annotations": total_annotations,
                "total_predictions": total_predictions,
                "unresolved_comment_count": unresolved_comment_count,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RoleBasedTask,
                    construct_type(
                        type_=RoleBasedTask,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_event(
        self,
        id: int,
        *,
        event_key: str,
        event_time: dt.datetime,
        annotation: typing.Optional[int] = OMIT,
        annotation_draft_id: typing.Optional[int] = OMIT,
        meta: typing.Optional[typing.Any] = OMIT,
        review: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TaskEvent]:
        """

            Create a new task event to track user interactions and system events during annotation.

            This endpoint is designed to receive events from the frontend labeling interface to enable
            accurate lead time calculation and detailed annotation analytics.

            ## Event Types

            **Core Annotation Events:**
            - `annotation_loaded` - When annotation interface is loaded
            - `annotation_created` - When annotation is submitted
            - `annotation_updated` - When annotation is modified
            - `annotation_reviewed` - When annotation is reviewed

            **User Activity Events:**
            - `visibility_change` - When page visibility changes (tab switch, minimize)
            - `idle_detected` - When user goes idle
            - `idle_resumed` - When user returns from idle

            **Interaction Events:**
            - `region_finished_drawing` - When annotation region is completed
            - `region_deleted` - When annotation regions are removed
            - `hotkey_pressed` - When keyboard shortcuts are used

            **Media Events:**
            - `video_playback_start/end` - Video playback control
            - `audio_playback_start/end` - Audio playback control
            - `video_scrub` - Video timeline scrubbing

            ## Usage

            Events are automatically associated with the task specified in the URL path.
            The current user is automatically set as the actor. Project and organization
            are derived from the task context.

            ## Example Request

            ```json
            {
                "event_key": "annotation_loaded",
                "event_time": "2024-01-15T10:30:00Z",
                "annotation": 123,
                "meta": {
                    "annotation_count": 5,
                    "estimated_time": 300
                }
            }
            ```


        Parameters
        ----------
        id : int
            Task ID to associate the event with

        event_key : str
            Event type identifier (e.g., "annotation_loaded", "region_finished_drawing")

        event_time : dt.datetime
            Timestamp when the event occurred (frontend time)

        annotation : typing.Optional[int]
            Annotation ID associated with this event

        annotation_draft_id : typing.Optional[int]
            Draft annotation ID associated with this event

        meta : typing.Optional[typing.Any]
            Additional event metadata (region data, hotkey info, etc.)

        review : typing.Optional[int]
            Review ID associated with this event

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TaskEvent]

        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/tasks/{jsonable_encoder(id)}/events/",
            method="POST",
            json={
                "annotation": annotation,
                "annotation_draft_id": annotation_draft_id,
                "event_key": event_key,
                "event_time": event_time,
                "meta": meta,
                "review": review,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskEvent,
                    construct_type(
                        type_=TaskEvent,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawTasksClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_many_status(
        self, id: int, import_pk: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ProjectImport]:
        """

                    Poll the status of an asynchronous project import operation.

                    **Usage:**
                    1. When you POST to `/api/projects/{project_id}/import`, you'll receive a response like `{"import": <import_id>}`
                    2. Use that `import_id` with this GET endpoint to check the import status
                    3. Poll this endpoint to see if the import has completed, is still processing, or has failed
                    4. **Import errors and failures will only be visible in this GET response**, not in the original POST request

                    This endpoint returns detailed information about the import including task counts, status, and any error messages.


        Parameters
        ----------
        id : int
            A unique integer value identifying this project import.

        import_pk : int

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ProjectImport]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/imports/{jsonable_encoder(import_pk)}/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProjectImport,
                    construct_type(
                        type_=ProjectImport,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_all_tasks(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete all tasks from a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this project.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/projects/{jsonable_encoder(id)}/tasks/",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list(
        self,
        *,
        fields: typing.Optional[ListTasksRequestFields] = None,
        include: typing.Optional[str] = None,
        only_annotated: typing.Optional[bool] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        project: typing.Optional[int] = None,
        query: typing.Optional[str] = None,
        resolve_uri: typing.Optional[bool] = None,
        review: typing.Optional[bool] = None,
        selected_items: typing.Optional[str] = None,
        view: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[RoleBasedTask, PaginatedRoleBasedTaskList]:
        """
        Retrieve a paginated list of tasks. The response format varies based on the user's role in the organization:
        - **Admin/Owner**: Full task details with all annotations, reviews, and metadata
        - **Reviewer**: Task details optimized for review workflow
        - **Annotator**: Task details filtered to show only user's own annotations and assignments

        Parameters
        ----------
        fields : typing.Optional[ListTasksRequestFields]
            Set to "all" if you want to include annotations and predictions in the response. Defaults to task_only

        include : typing.Optional[str]
            Specify which fields to include in the response

        only_annotated : typing.Optional[bool]
            Filter to show only tasks that have annotations

        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        project : typing.Optional[int]
            Project ID

        query : typing.Optional[str]
            Additional query to filter tasks. It must be JSON encoded string of dict containing one of the following parameters: {"filters": ..., "selectedItems": ..., "ordering": ...}. Check Data Manager > Create View > see data field for more details about filters, selectedItems and ordering.

            filters: dict with "conjunction" string ("or" or "and") and list of filters in "items" array. Each filter is a dictionary with keys: "filter", "operator", "type", "value". Read more about available filters
            Example: {"conjunction": "or", "items": [{"filter": "filter:tasks:completed_at", "operator": "greater", "type": "Datetime", "value": "2021-01-01T00:00:00.000Z"}]}
            selectedItems: dictionary with keys: "all", "included", "excluded". If "all" is false, "included" must be used. If "all" is true, "excluded" must be used.
            Examples: {"all": false, "included": [1, 2, 3]} or {"all": true, "excluded": [4, 5]}
            ordering: list of fields to order by. Currently, ordering is supported by only one parameter.
            Example: ["completed_at"]

        resolve_uri : typing.Optional[bool]
            Resolve task data URIs using Cloud Storage

        review : typing.Optional[bool]
            Get tasks for review

        selected_items : typing.Optional[str]
            JSON string of selected task IDs for review workflow

        view : typing.Optional[int]
            View ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[RoleBasedTask, PaginatedRoleBasedTaskList]

        """
        page = page if page is not None else 1

        _response = await self._client_wrapper.httpx_client.request(
            "api/tasks/",
            method="GET",
            params={
                "fields": fields,
                "include": include,
                "only_annotated": only_annotated,
                "page": page,
                "page_size": page_size,
                "project": project,
                "query": query,
                "resolve_uri": resolve_uri,
                "review": review,
                "selectedItems": selected_items,
                "view": view,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    PaginatedRoleBasedTaskList,
                    construct_type(
                        type_=PaginatedRoleBasedTaskList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.tasks
                _has_next = True

                async def _get_next():
                    return await self.list(
                        fields=fields,
                        include=include,
                        only_annotated=only_annotated,
                        page=page + 1,
                        page_size=page_size,
                        project=project,
                        query=query,
                        resolve_uri=resolve_uri,
                        review=review,
                        selected_items=selected_items,
                        view=view,
                        request_options=request_options,
                    )

                return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next, response=_parsed_response)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        data: typing.Any,
        allow_skip: typing.Optional[bool] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.Sequence[int]] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        is_labeled: typing.Optional[bool] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        meta: typing.Optional[typing.Any] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        project: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[LseTask]:
        """
        Create a new task

        Parameters
        ----------
        data : typing.Any

        allow_skip : typing.Optional[bool]
            Whether this task can be skipped. Set to False to make task unskippable.

        cancelled_annotations : typing.Optional[int]
            Number of total cancelled annotations for the current task

        comment_authors : typing.Optional[typing.Sequence[int]]
            Users who wrote comments

        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations

        file_upload : typing.Optional[int]
            Uploaded file used as data source for this task

        inner_id : typing.Optional[int]
            Internal task ID in the project, starts with 1

        is_labeled : typing.Optional[bool]
            True if the number of annotations for this task is greater than or equal to the number of maximum_completions for the project

        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated

        meta : typing.Optional[typing.Any]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.

        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task

        project : typing.Optional[int]
            Project ID for this task

        total_annotations : typing.Optional[int]
            Number of total annotations for the current task except cancelled annotations

        total_predictions : typing.Optional[int]
            Number of total predictions for the current task

        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations

        updated_by : typing.Optional[int]
            Last annotator or reviewer who updated this task

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[LseTask]

        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/tasks/",
            method="POST",
            json={
                "allow_skip": allow_skip,
                "cancelled_annotations": cancelled_annotations,
                "comment_authors": comment_authors,
                "comment_count": comment_count,
                "data": data,
                "file_upload": file_upload,
                "inner_id": inner_id,
                "is_labeled": is_labeled,
                "last_comment_updated_at": last_comment_updated_at,
                "meta": meta,
                "overlap": overlap,
                "project": project,
                "total_annotations": total_annotations,
                "total_predictions": total_predictions,
                "unresolved_comment_count": unresolved_comment_count,
                "updated_by": updated_by,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LseTask,
                    construct_type(
                        type_=LseTask,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[RoleBasedTask]:
        """
        Get task data, metadata, annotations and other attributes for a specific labeling task by task ID.

        Parameters
        ----------
        id : str
            Task ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RoleBasedTask]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/tasks/{jsonable_encoder(id)}/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RoleBasedTask,
                    construct_type(
                        type_=RoleBasedTask,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete a task in Label Studio. This action cannot be undone!

        Parameters
        ----------
        id : str
            Task ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/tasks/{jsonable_encoder(id)}/",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        id: str,
        *,
        allow_skip: typing.Optional[bool] = OMIT,
        avg_lead_time: typing.Optional[float] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        completed_at: typing.Optional[dt.datetime] = OMIT,
        data: typing.Optional[typing.Any] = OMIT,
        draft_exists: typing.Optional[bool] = OMIT,
        ground_truth: typing.Optional[bool] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        is_labeled: typing.Optional[bool] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        meta: typing.Optional[typing.Any] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        precomputed_agreement: typing.Optional[float] = OMIT,
        predictions_score: typing.Optional[float] = OMIT,
        project: typing.Optional[int] = OMIT,
        reviewed: typing.Optional[bool] = OMIT,
        reviews_accepted: typing.Optional[int] = OMIT,
        reviews_rejected: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RoleBasedTask]:
        """
        Update the attributes of an existing labeling task.

        Parameters
        ----------
        id : str
            Task ID

        allow_skip : typing.Optional[bool]
            Whether this task can be skipped. Set to False to make task unskippable.

        avg_lead_time : typing.Optional[float]

        cancelled_annotations : typing.Optional[int]

        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations

        completed_at : typing.Optional[dt.datetime]

        data : typing.Optional[typing.Any]
            User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.

        draft_exists : typing.Optional[bool]

        ground_truth : typing.Optional[bool]

        inner_id : typing.Optional[int]

        is_labeled : typing.Optional[bool]
            True if the number of annotations for this task is greater than or equal to the number of maximum_completions for the project

        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated

        meta : typing.Optional[typing.Any]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.

        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task

        precomputed_agreement : typing.Optional[float]
            Average agreement score for the task

        predictions_score : typing.Optional[float]

        project : typing.Optional[int]
            Project ID for this task

        reviewed : typing.Optional[bool]

        reviews_accepted : typing.Optional[int]

        reviews_rejected : typing.Optional[int]

        total_annotations : typing.Optional[int]

        total_predictions : typing.Optional[int]

        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RoleBasedTask]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/tasks/{jsonable_encoder(id)}/",
            method="PATCH",
            json={
                "allow_skip": allow_skip,
                "avg_lead_time": avg_lead_time,
                "cancelled_annotations": cancelled_annotations,
                "comment_count": comment_count,
                "completed_at": completed_at,
                "data": data,
                "draft_exists": draft_exists,
                "ground_truth": ground_truth,
                "inner_id": inner_id,
                "is_labeled": is_labeled,
                "last_comment_updated_at": last_comment_updated_at,
                "meta": meta,
                "overlap": overlap,
                "precomputed_agreement": precomputed_agreement,
                "predictions_score": predictions_score,
                "project": project,
                "reviewed": reviewed,
                "reviews_accepted": reviews_accepted,
                "reviews_rejected": reviews_rejected,
                "total_annotations": total_annotations,
                "total_predictions": total_predictions,
                "unresolved_comment_count": unresolved_comment_count,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RoleBasedTask,
                    construct_type(
                        type_=RoleBasedTask,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_event(
        self,
        id: int,
        *,
        event_key: str,
        event_time: dt.datetime,
        annotation: typing.Optional[int] = OMIT,
        annotation_draft_id: typing.Optional[int] = OMIT,
        meta: typing.Optional[typing.Any] = OMIT,
        review: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TaskEvent]:
        """

            Create a new task event to track user interactions and system events during annotation.

            This endpoint is designed to receive events from the frontend labeling interface to enable
            accurate lead time calculation and detailed annotation analytics.

            ## Event Types

            **Core Annotation Events:**
            - `annotation_loaded` - When annotation interface is loaded
            - `annotation_created` - When annotation is submitted
            - `annotation_updated` - When annotation is modified
            - `annotation_reviewed` - When annotation is reviewed

            **User Activity Events:**
            - `visibility_change` - When page visibility changes (tab switch, minimize)
            - `idle_detected` - When user goes idle
            - `idle_resumed` - When user returns from idle

            **Interaction Events:**
            - `region_finished_drawing` - When annotation region is completed
            - `region_deleted` - When annotation regions are removed
            - `hotkey_pressed` - When keyboard shortcuts are used

            **Media Events:**
            - `video_playback_start/end` - Video playback control
            - `audio_playback_start/end` - Audio playback control
            - `video_scrub` - Video timeline scrubbing

            ## Usage

            Events are automatically associated with the task specified in the URL path.
            The current user is automatically set as the actor. Project and organization
            are derived from the task context.

            ## Example Request

            ```json
            {
                "event_key": "annotation_loaded",
                "event_time": "2024-01-15T10:30:00Z",
                "annotation": 123,
                "meta": {
                    "annotation_count": 5,
                    "estimated_time": 300
                }
            }
            ```


        Parameters
        ----------
        id : int
            Task ID to associate the event with

        event_key : str
            Event type identifier (e.g., "annotation_loaded", "region_finished_drawing")

        event_time : dt.datetime
            Timestamp when the event occurred (frontend time)

        annotation : typing.Optional[int]
            Annotation ID associated with this event

        annotation_draft_id : typing.Optional[int]
            Draft annotation ID associated with this event

        meta : typing.Optional[typing.Any]
            Additional event metadata (region data, hotkey info, etc.)

        review : typing.Optional[int]
            Review ID associated with this event

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TaskEvent]

        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/tasks/{jsonable_encoder(id)}/events/",
            method="POST",
            json={
                "annotation": annotation,
                "annotation_draft_id": annotation_draft_id,
                "event_key": event_key,
                "event_time": event_time,
                "meta": meta,
                "review": review,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TaskEvent,
                    construct_type(
                        type_=TaskEvent,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        construct_type(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
