# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import pydantic_v1
from ..core.query_encoder import encode_query
from ..core.remove_none_from_dict import remove_none_from_dict
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..types.annotation import Annotation
from ..types.file_upload import FileUpload
from ..types.prediction import Prediction
from .types.api_projects_import_create_response import ApiProjectsImportCreateResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ImportClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def api_import_file_upload_read(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> FileUpload:
        """
        Retrieve details about a specific uploaded file.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileUpload


        Examples
        --------
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.import.api_import_file_upload_read(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{jsonable_encoder(id)}"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(FileUpload, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_import_file_upload_delete(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete a specific uploaded file.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.import.api_import_file_upload_delete(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{jsonable_encoder(id)}"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_import_file_upload_partial_update(
        self, id: int, *, request: FileUpload, request_options: typing.Optional[RequestOptions] = None
    ) -> FileUpload:
        """
        Update a specific uploaded file.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        request : FileUpload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileUpload


        Examples
        --------
        from label-studio import FileUpload
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.import.api_import_file_upload_partial_update(id=1, request=FileUpload(), )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="PATCH",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{jsonable_encoder(id)}"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(FileUpload, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_file_uploads_list(
        self,
        id: int,
        *,
        all_: typing.Optional[bool] = None,
        ids: typing.Optional[typing.Union[int, typing.Sequence[int]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[FileUpload]:
        """
        Retrieve the list of uploaded files used to create labeling tasks for a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        all_ : typing.Optional[bool]
            Set to "true" if you want to retrieve all file uploads

        ids : typing.Optional[typing.Union[int, typing.Sequence[int]]]
            Specify the list of file upload IDs to retrieve, e.g. ids=[1,2,3]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileUpload]


        Examples
        --------
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.import.api_projects_file_uploads_list(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/file-uploads"
            ),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        {
                            "all": all_,
                            "ids": ids,
                            **(
                                request_options.get("additional_query_parameters", {})
                                if request_options is not None
                                else {}
                            ),
                        }
                    )
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(typing.List[FileUpload], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_file_uploads_delete(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete uploaded files for a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label-studio.client import LabelStudioApi

        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.import.api_projects_file_uploads_delete(id=1, )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/file-uploads"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def api_projects_import_create(
        self,
        id: int,
        *,
        data: typing.Dict[str, typing.Any],
        import_api_id: typing.Optional[int] = OMIT,
        annotations: typing.Optional[typing.Sequence[Annotation]] = OMIT,
        predictions: typing.Optional[typing.Sequence[Prediction]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiProjectsImportCreateResponse:
        """
        Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
        One POST request is limited at 250K tasks and 200 MB.
        
        **Note:** Imported data is verified against a project _label_config_ and must
        include all variables that were used in the _label_config_. For example,
        if the label configuration has a _$text_ variable, then each item in a data object
        must include a "text" field.
        <br>
        
        ## POST requests
        
        <hr style="opacity:0.3">
        
        There are three possible ways to import tasks with this endpoint:
        
        ### 1\. **POST with data**
        
        Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
        Update this example to specify your authorization token and Label Studio instance host, then run the following from
        the command line.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
        ```
        
        ### 2\. **POST with files**
        
        Send tasks as files. You can attach multiple files with different names.
        
        - **JSON**: text files in JavaScript object notation format
        - **CSV**: text files with tables in Comma Separated Values format
        - **TSV**: text files with tables in Tab Separated Value format
        - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
        Update this example to specify your authorization token, Label Studio instance host, and file name and path,
        then run the following from the command line:
        
        ```bash
        curl -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' -F ‘file=@path/to/my_file.csv’
        ```
        
        ### 3\. **POST with URL**
        
        You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' \
        --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
        ```
        
        <br>
        
        Parameters
        ----------
        id : int
            A unique integer value identifying this project.
        
        data : typing.Dict[str, typing.Any]
            User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.
        
        import_api_id : typing.Optional[int]
        
        annotations : typing.Optional[typing.Sequence[Annotation]]
        
        predictions : typing.Optional[typing.Sequence[Prediction]]
        
        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.
        
        created_at : typing.Optional[dt.datetime]
            Time a task was created
        
        updated_at : typing.Optional[dt.datetime]
            Last time a task was updated
        
        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task
        
        inner_id : typing.Optional[int]
            Internal task ID in the project, starts with 1
        
        total_annotations : typing.Optional[int]
            Number of total annotations for the current task except cancelled annotations
        
        cancelled_annotations : typing.Optional[int]
            Number of total cancelled annotations for the current task
        
        total_predictions : typing.Optional[int]
            Number of total predictions for the current task
        
        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations
        
        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations
        
        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated
        
        updated_by : typing.Optional[int]
            Last annotator or reviewer who updated this task
        
        file_upload : typing.Optional[int]
            Uploaded file used as data source for this task
        
        comment_authors : typing.Optional[typing.Sequence[int]]
            Users who wrote comments
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        ApiProjectsImportCreateResponse
            Tasks successfully imported
        
        Examples
        --------
        from label-studio.client import LabelStudioApi
        
        client = LabelStudioApi(api_key="YOUR_API_KEY", )
        client.import.api_projects_import_create(id=1, data={}, )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if import_api_id is not OMIT:
            _request["id"] = import_api_id
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if predictions is not OMIT:
            _request["predictions"] = predictions
        if meta is not OMIT:
            _request["meta"] = meta
        if created_at is not OMIT:
            _request["created_at"] = created_at
        if updated_at is not OMIT:
            _request["updated_at"] = updated_at
        if overlap is not OMIT:
            _request["overlap"] = overlap
        if inner_id is not OMIT:
            _request["inner_id"] = inner_id
        if total_annotations is not OMIT:
            _request["total_annotations"] = total_annotations
        if cancelled_annotations is not OMIT:
            _request["cancelled_annotations"] = cancelled_annotations
        if total_predictions is not OMIT:
            _request["total_predictions"] = total_predictions
        if comment_count is not OMIT:
            _request["comment_count"] = comment_count
        if unresolved_comment_count is not OMIT:
            _request["unresolved_comment_count"] = unresolved_comment_count
        if last_comment_updated_at is not OMIT:
            _request["last_comment_updated_at"] = last_comment_updated_at
        if updated_by is not OMIT:
            _request["updated_by"] = updated_by
        if file_upload is not OMIT:
            _request["file_upload"] = file_upload
        if comment_authors is not OMIT:
            _request["comment_authors"] = comment_authors
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/import"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ApiProjectsImportCreateResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncImportClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def api_import_file_upload_read(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> FileUpload:
        """
        Retrieve details about a specific uploaded file.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileUpload


        Examples
        --------
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.import.api_import_file_upload_read(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{jsonable_encoder(id)}"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(FileUpload, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_import_file_upload_delete(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete a specific uploaded file.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.import.api_import_file_upload_delete(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{jsonable_encoder(id)}"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_import_file_upload_partial_update(
        self, id: int, *, request: FileUpload, request_options: typing.Optional[RequestOptions] = None
    ) -> FileUpload:
        """
        Update a specific uploaded file.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        request : FileUpload

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        FileUpload


        Examples
        --------
        from label-studio import FileUpload
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.import.api_import_file_upload_partial_update(id=1, request=FileUpload(), )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="PATCH",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/import/file-upload/{jsonable_encoder(id)}"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(FileUpload, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_file_uploads_list(
        self,
        id: int,
        *,
        all_: typing.Optional[bool] = None,
        ids: typing.Optional[typing.Union[int, typing.Sequence[int]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[FileUpload]:
        """
        Retrieve the list of uploaded files used to create labeling tasks for a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        all_ : typing.Optional[bool]
            Set to "true" if you want to retrieve all file uploads

        ids : typing.Optional[typing.Union[int, typing.Sequence[int]]]
            Specify the list of file upload IDs to retrieve, e.g. ids=[1,2,3]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[FileUpload]


        Examples
        --------
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.import.api_projects_file_uploads_list(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/file-uploads"
            ),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        {
                            "all": all_,
                            "ids": ids,
                            **(
                                request_options.get("additional_query_parameters", {})
                                if request_options is not None
                                else {}
                            ),
                        }
                    )
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(typing.List[FileUpload], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_file_uploads_delete(
        self, id: int, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Delete uploaded files for a specific project.

        Parameters
        ----------
        id : int
            A unique integer value identifying this file upload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label-studio.client import AsyncLabelStudioApi

        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.import.api_projects_file_uploads_delete(id=1, )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/file-uploads"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def api_projects_import_create(
        self,
        id: int,
        *,
        data: typing.Dict[str, typing.Any],
        import_api_id: typing.Optional[int] = OMIT,
        annotations: typing.Optional[typing.Sequence[Annotation]] = OMIT,
        predictions: typing.Optional[typing.Sequence[Prediction]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ApiProjectsImportCreateResponse:
        """
        Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
        One POST request is limited at 250K tasks and 200 MB.
        
        **Note:** Imported data is verified against a project _label_config_ and must
        include all variables that were used in the _label_config_. For example,
        if the label configuration has a _$text_ variable, then each item in a data object
        must include a "text" field.
        <br>
        
        ## POST requests
        
        <hr style="opacity:0.3">
        
        There are three possible ways to import tasks with this endpoint:
        
        ### 1\. **POST with data**
        
        Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
        Update this example to specify your authorization token and Label Studio instance host, then run the following from
        the command line.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
        ```
        
        ### 2\. **POST with files**
        
        Send tasks as files. You can attach multiple files with different names.
        
        - **JSON**: text files in JavaScript object notation format
        - **CSV**: text files with tables in Comma Separated Values format
        - **TSV**: text files with tables in Tab Separated Value format
        - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
        Update this example to specify your authorization token, Label Studio instance host, and file name and path,
        then run the following from the command line:
        
        ```bash
        curl -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' -F ‘file=@path/to/my_file.csv’
        ```
        
        ### 3\. **POST with URL**
        
        You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' \
        --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
        ```
        
        <br>
        
        Parameters
        ----------
        id : int
            A unique integer value identifying this project.
        
        data : typing.Dict[str, typing.Any]
            User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.
        
        import_api_id : typing.Optional[int]
        
        annotations : typing.Optional[typing.Sequence[Annotation]]
        
        predictions : typing.Optional[typing.Sequence[Prediction]]
        
        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.
        
        created_at : typing.Optional[dt.datetime]
            Time a task was created
        
        updated_at : typing.Optional[dt.datetime]
            Last time a task was updated
        
        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task
        
        inner_id : typing.Optional[int]
            Internal task ID in the project, starts with 1
        
        total_annotations : typing.Optional[int]
            Number of total annotations for the current task except cancelled annotations
        
        cancelled_annotations : typing.Optional[int]
            Number of total cancelled annotations for the current task
        
        total_predictions : typing.Optional[int]
            Number of total predictions for the current task
        
        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations
        
        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations
        
        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated
        
        updated_by : typing.Optional[int]
            Last annotator or reviewer who updated this task
        
        file_upload : typing.Optional[int]
            Uploaded file used as data source for this task
        
        comment_authors : typing.Optional[typing.Sequence[int]]
            Users who wrote comments
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        ApiProjectsImportCreateResponse
            Tasks successfully imported
        
        Examples
        --------
        from label-studio.client import AsyncLabelStudioApi
        
        client = AsyncLabelStudioApi(api_key="YOUR_API_KEY", )
        await client.import.api_projects_import_create(id=1, data={}, )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if import_api_id is not OMIT:
            _request["id"] = import_api_id
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if predictions is not OMIT:
            _request["predictions"] = predictions
        if meta is not OMIT:
            _request["meta"] = meta
        if created_at is not OMIT:
            _request["created_at"] = created_at
        if updated_at is not OMIT:
            _request["updated_at"] = updated_at
        if overlap is not OMIT:
            _request["overlap"] = overlap
        if inner_id is not OMIT:
            _request["inner_id"] = inner_id
        if total_annotations is not OMIT:
            _request["total_annotations"] = total_annotations
        if cancelled_annotations is not OMIT:
            _request["cancelled_annotations"] = cancelled_annotations
        if total_predictions is not OMIT:
            _request["total_predictions"] = total_predictions
        if comment_count is not OMIT:
            _request["comment_count"] = comment_count
        if unresolved_comment_count is not OMIT:
            _request["unresolved_comment_count"] = unresolved_comment_count
        if last_comment_updated_at is not OMIT:
            _request["last_comment_updated_at"] = last_comment_updated_at
        if updated_by is not OMIT:
            _request["updated_by"] = updated_by
        if file_upload is not OMIT:
            _request["file_upload"] = file_upload
        if comment_authors is not OMIT:
            _request["comment_authors"] = comment_authors
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/import"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ApiProjectsImportCreateResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
